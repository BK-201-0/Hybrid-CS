[
    {
        "nl_input": "The query requires a function to replace the current owner with a new owner in a contract. It needs to ensure the transaction is sent by an authorized wallet, validate the existence of the old owner and non-existence of the new owner, update the owner list, and emit events for owner removal and addition.",
        "url": 0
    },
    {
        "nl_input": "The query requires a function to compute the real cap using a given cap value and key, producing a hash as the result. Specifically, it needs a method that takes two uint256 inputs (_cap and _key) and returns a bytes32 hash computed using the keccak256 algorithm. This ensures a unique and deterministic real cap hash output.",
        "url": 1
    },
    {
        "nl_input": "The query requires a constructor function where the function name must match the contract name declared above. Among the provided code snippets, none perfectly match this requirement as an explicit constructor. However, the query focuses on ensuring that the function name aligns with the contract name to serve as a constructor in older Solidity versions. This alignment is crucial for contract initialization.",
        "url": 2
    },
    {
        "nl_input": "The query requires determining the amount of Kitten Coins (or equivalent tokens) one needs to hold to qualify for holder rewards. This involves identifying thresholds or conditions within the code that specify bonus structures, token balances, or reward calculations based on the quantity of tokens held by investors or users.",
        "url": 3
    },
    {
        "nl_input": "The query requires a function to retrieve the balance of a specific account, given its address. The function should take an address as input and return the corresponding balance. This is intended for querying the number of tokens or funds owned by a particular account in a token or financial contract system.",
        "url": 4
    },
    {
        "nl_input": "The query requires a function to burn BNTTs from users' balances. It needs to check if the user has sufficient tokens and subtract the specified amount from their balance and the total supply, emitting a 'Burn' event with the user's address and the value burnt. The function should ensure valid values and proper authorization.",
        "url": 5
    },
    {
        "nl_input": "The query requires a method to update the current state of funding tranches and rounds. It involves transitioning between funding rounds based on specific caps, resetting the current round when advancing, and marking the process as successful upon completion. The method should handle state changes and ensure proper progression through the funding stages.",
        "url": 6
    },
    {
        "nl_input": "The query requires a mechanism to execute actions when a specific condition is met, such as a time-based event or contract termination. It needs code that handles scenarios like self-destruction, sending remaining balances, or checking if a contract has ended based on time or resource constraints. The focus is on conditional logic for contract closure or state transition.",
        "url": 7
    },
    {
        "nl_input": "The query requires a function that logs or retrieves a data request using a specific ID. It should involve accessing stored requests, identifying the request by its unique ID, and potentially returning or emitting details associated with that request, such as initialization status, URL, or related data points.",
        "url": 8
    },
    {
        "nl_input": "The query requires a function allowing the controller to relinquish control. The desired code should include a mechanism for the current controller to step down, typically by setting the controller address to zero and emitting an event to notify about the change. This ensures the controller role can be voluntarily abandoned or transferred to no one.",
        "url": 9
    },
    {
        "nl_input": "The query requires a function to facilitate token withdrawals from a contract after specific conditions are met, such as the completion of a game or crowdsale. The function should ensure proper balance calculations, handle fees if applicable, and transfer tokens or Ether to the user's address while maintaining security and validity checks.",
        "url": 10
    },
    {
        "nl_input": "The query requires a public interface function to access the directory of games, including details such as contract address, description, URL, submitter, and timestamp. It needs a way to retrieve the total number of games and check if a specific game is active. The focus is on providing a comprehensive public access point for game records.",
        "url": 11
    },
    {
        "nl_input": "The query requires a function that allows users to retrieve their assigned prize, calculated based on the tokens they own. It should transfer the prize to the caller if they have a valid prize, reverting the transaction if no prize is available, ensuring no gas cost to the user. The solution must handle prize calculation and distribution efficiently.",
        "url": 12
    },
    {
        "nl_input": "The query requires implementing a function to add a new casino with specific attributes, such as ID, star rating, owner, price, name, and description. The function should store the casino details in a structured format and update a list of casino IDs. This ensures each casino is uniquely identifiable and its information is easily accessible.",
        "url": 13
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one account to another, ensuring the balance is updated accordingly and possibly involving approval checks. It should handle token subtraction from the sender, addition to the recipient, and may include event logging or specific conditions for execution.",
        "url": 14
    },
    {
        "nl_input": "The query requires a function to toggle a locked flag, allowing the owner to change the state of the \"locked\" variable between true and false. It involves emitting an event to notify about the change and ensures only the owner can perform this action. The focus is on enabling reversible locking functionality with proper access control.",
        "url": 15
    },
    {
        "nl_input": "The query requires a function that enables the `pendingOwner` address to complete ownership transfer within a specified block range. The function should ensure the caller is the pending owner and reset relevant variables upon successful execution. This involves verifying block number constraints, transferring ownership, and clearing the pending owner and time parameters.",
        "url": 16
    },
    {
        "nl_input": "The query requires a description of overriding the transfer function to include custom logic before executing the token transfer. This involves checking conditions such as permission (isTransferAllowed) or state variables (tokensTradeable & unlockedTokensInternal) before calling the parent class's transfer function to ensure controlled token transfers.",
        "url": 17
    },
    {
        "nl_input": "The query requires a function to allocate tokens to specified addresses with optional parameters for tracking and investment details. It should support multiple allocations, ensure proper ownership, and handle token distribution accurately while maintaining supply integrity and providing optional customer UUID and wei amount for external payment tracking.",
        "url": 18
    },
    {
        "nl_input": "The query requires a function that correctly implements the ERC20 token standard's \"allowance\" functionality, which checks the remaining tokens an owner allows a spender to withdraw. The implementation should return the precise value of allowed tokens between an owner and spender, adhering to the ERC20 specification without always returning zero or disallowed values.",
        "url": 19
    },
    {
        "nl_input": "The query requires a function that delegates execution to an implementation contract using the delegatecall mechanism. It should transfer control to the specified contract address, executing its code in the context of the delegating contract and returning the result to the external caller. The function must handle errors and return data appropriately.",
        "url": 20
    },
    {
        "nl_input": "The query requires a function to cancel pending operations, specifically within the context of smart contracts. The provided code examples include functionalities such as canceling project statuses, withdrawal requests, and modifiers for state-dependent execution. The requirement focuses on implementing a mechanism to halt or reset ongoing processes or requests in a blockchain environment.",
        "url": 21
    },
    {
        "nl_input": "The query requires a function to check if the length of a string is within a specified minimum and maximum range. The desired function should take a string and two uint values as inputs and return a boolean indicating whether the string's length satisfies the given constraints. This ensures the string's length is not less than the minimum or greater than the maximum value provided.",
        "url": 22
    },
    {
        "nl_input": "The query requires setting a cooldown period for childbirth, specifically updating the cooldown for a mother entity (e.g., rabbit, dog, or zodiac) after breeding. This involves modifying the entity's cooldown attributes, such as incrementing the birth count, updating the last birth time, or adjusting the cooldown index and end block. The implementation ensures proper tracking of breeding events and cooldown status.",
        "url": 23
    },
    {
        "nl_input": "The query requires a function to set a specific contract address that has permission to call the 'vacate' function on this contract. This involves defining a function within a smart contract that accepts an address parameter and assigns it as the authorized caller for the 'vacate' function, ensuring proper access control.",
        "url": 24
    },
    {
        "nl_input": "The query requires a function to buy tokens using Ether, ensuring conditions like minimum transaction amount, supply limits, and sale phase are met. It involves calculating tokens based on Ether value, updating supply and buyer balance, and logging the transaction. The function should handle requirements such as rate calculation, minting tokens, and transferring funds to a wallet.",
        "url": 25
    },
    {
        "nl_input": "The query requires a function to determine the number of token base units per grain. The most relevant code provides a function `tokenUnits` that retrieves an array of token units from a list of tokens, aligning with the need to calculate or retrieve the number of token base units required per grain as specified in the query.",
        "url": 26
    },
    {
        "nl_input": "The query requires a function to update a specific address (e.g., multi-signature, signer, or wallet address) within a smart contract. The function should restrict access to authorized entities (e.g., onlyMultiSig, onlyOwner) and include a validation check to ensure the new address is not null. It may also trigger an event or notification upon successful change.",
        "url": 27
    },
    {
        "nl_input": "The query requires identifying if the burnToken function has ended. It needs a true return value when the burnToken function completes, ensuring conditions like hasEnded() are met, tokens are burned, and supplies are reset. The function should be callable only by the owner and when not paused, returning a boolean to confirm completion.",
        "url": 28
    },
    {
        "nl_input": "The query requires a function allowing TGE participants to request refunds if the token generation minimum is not met. The function should verify the participant's eligibility, reclaim their tokens, refund their contribution in Ether, and adjust relevant balances and statuses accordingly. It must ensure proper conditions are met before executing the refund.",
        "url": 29
    },
    {
        "nl_input": "The query requires a function or modifier that ensures a specific condition for execution, such as limiting function calls to once or restricting execution to a particular caller. The focus is on enforcing rules like quorum requirements or ensuring the caller is authorized, typically through contract-specific scripts or addresses. This involves using modifiers or internal checks to validate the caller's eligibility.",
        "url": 30
    },
    {
        "nl_input": "The query requires a function to retrieve the token balance of a specified wallet address. The function should take an address as input and return the balance of tokens in that wallet. The provided code examples demonstrate implementations of such a function, named `balanceOf`, which returns the token balance associated with the given address.",
        "url": 31
    },
    {
        "nl_input": "The query requires a function to determine the number of wei needed to purchase 0.01 Mozo tokens. It focuses on retrieving the rate value that defines the conversion between wei and Mozo tokens, ensuring accurate calculation for token purchases based on wei input. The relevant code should provide a direct method to obtain this specific rate.",
        "url": 32
    },
    {
        "nl_input": "The query requires a function to transfer ethers held by the contract to the owner's address. It should be invokable only by the owner for security, ensuring that the owner can rescue or drain ethers when needed, either fully or by specifying an amount. The function must handle transfers safely and confirm successful execution.",
        "url": 33
    },
    {
        "nl_input": "The query requires a function or modifier that manages owner configuration in a smart contract, specifically focusing on changing or setting the owner. It needs code elements that ensure only the current owner can execute ownership changes and possibly include event logging or return values to confirm successful owner updates.",
        "url": 34
    },
    {
        "nl_input": "The query requires a function to calculate the amount of tokens and their equivalent value in USD based on the input value. It involves converting the input value to USD, determining the token amount using internal calculations, and returning both the token amount and USD value. The focus is on functions that handle token calculation with respect to USD conversion.",
        "url": 35
    },
    {
        "nl_input": "The query requires methods for user authorisation management. Specifically, it involves adding addresses to an authorised list, checking if a caller is an authorised user, and managing authorisations with modifiers or functions that ensure only authorised entities can perform certain actions. The focus is on implementing access control mechanisms in smart contracts.",
        "url": 36
    },
    {
        "nl_input": "The query requires a function allowing customers to buy a box, involving payment, validation, and potential random outcomes or bonuses. The selected code should handle transactions, ensure conditions are met (e.g., price, availability), and possibly include additional logic like creating items or transferring excess funds.",
        "url": 37
    },
    {
        "nl_input": "The query requires a function to retrieve sale prices of properties in ETH and PXL. Specifically, it needs to check if a property is system-owned and return system sale prices or return the sale price set by the property owner. The function should accept a property ID as input and return two values representing the sale prices in both currencies.",
        "url": 38
    },
    {
        "nl_input": "The query requires a function to determine the total remaining free trial drops for a specific token. It needs to check if the token qualifies for a free trial and calculate the difference between the maximum allowed drops and the ones already used, returning zero if the token doesn't qualify.",
        "url": 39
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract, which may also result in the destruction of the contract. The desired functionality involves transferring any remaining funds to the owner before terminating the contract, ensuring that ownership is relinquished and resources are properly handled.",
        "url": 40
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the sender's address to a specified address, ensuring the value is positive, deducting the amount from the sender's balance, adding it to the receiver's balance, and emitting a transfer event. The function should return a boolean indicating success.",
        "url": 41
    },
    {
        "nl_input": "The query requires a function that allows the owner to modify the exchange rate of tokens, with a default rate of 0.005 Ether. The function should ensure only the owner can make changes and may include logic for adjusting rates dynamically based on specific conditions, such as total revenue or token supply.",
        "url": 42
    },
    {
        "nl_input": "The query requires a function that returns a subscription deposit to the customer immediately when a subscription is canceled. The function should verify the subscription state, ensure there's a deposit amount, and confirm the caller's authorization before returning the deposit.",
        "url": 43
    },
    {
        "nl_input": "The query requires a function to set an approval expiry window before the contract is locked. It needs a parameter for expiry time, specified either in seconds or milliseconds since 1970, and should restrict access to the owner prior to contract locking. The function must enable configuring the time window to control approval validity.",
        "url": 44
    },
    {
        "nl_input": "The query requires a function to retrieve the BOP balance for a given address. The function should take an address as input and return the balance associated with that address, typically using a mapping or controller-based balance retrieval mechanism. The provided code examples demonstrate variations of such a function, named `balanceOf`, which fulfills this requirement.",
        "url": 45
    },
    {
        "nl_input": "The query requires identifying functions that are defined as pure, which do not interact with blockchain state. The focus is on ensuring such functions are declared as \"pure\" instead of \"constant.\" The extracted information highlights the need for a pure function example, like the \"allowance\" function returning a fixed value without state interaction.",
        "url": 46
    },
    {
        "nl_input": "The query requires a function to reallocate unsold and leftover bounty tokens. Specifically, it needs a mechanism to withdraw or transfer these tokens back to the seller or distribute them accordingly. The focus is on ensuring that any remaining tokens after a sale or distribution period are properly handled and accounted for within the contract.",
        "url": 47
    },
    {
        "nl_input": "The query requires a function to cancel a withdrawal request, allowing users to change their minds and continue using the system. It involves resetting a specific user's withdrawal status to ensure they can still participate or play after retracting their request.",
        "url": 48
    },
    {
        "nl_input": "The query requires a function to mint tokens and assign them to a specific address. It needs to ensure the address is valid, update the token balance for the address, and emit a transfer event indicating the minting process. The function should take the target address and the token ID or amount as parameters.",
        "url": 49
    },
    {
        "nl_input": "The query requires a function to determine the current bonus during the ICO stage based on timestamps. It should return specific bonus percentages for each week of the ICO, reducing over time. The function must consider the current timestamp and predefined bonus stages, ensuring the correct bonus is applied according to the ICO phase. If the timestamp exceeds the final bonus stage, the bonus should be zero.",
        "url": 50
    },
    {
        "nl_input": "The query requires a function to allocate tokens to all token bankrolls. It needs a mechanism to iterate through a list of token amounts or recipients and allocate tokens accordingly, potentially using a private allocation function like `_tokenAllocate`. The solution should ensure that each specified token amount or recipient is processed during the allocation process.",
        "url": 51
    },
    {
        "nl_input": "The query requires a function to transfer token balances from the owner's account to another account, ensuring the owner has sufficient balance. It allows 0-value transfers and includes a developer override. The function should handle typical transfer logic, including updating balances and emitting events, while accommodating special conditions like dev overrides and specific requirements for valid transfers.",
        "url": 52
    },
    {
        "nl_input": "The query requires a function to send a token to a user's address. It needs a method that takes an address as a parameter and transfers token ownership to that address, ensuring the sender is authorized and the transaction is successfully recorded. The function should handle balance updates and emit a transfer event for transparency and confirmation of the transaction.",
        "url": 53
    },
    {
        "nl_input": "The query requires extracting 256-bit data from a bytes stream. It needs a function that takes a byte array and an offset, processes 32 bytes starting from the offset, and returns a 256-bit (32-byte) result by combining the byte values appropriately. This ensures the correct bit-shifting and aggregation of the byte sequence into a single output.",
        "url": 54
    },
    {
        "nl_input": "The query requires a function to retrieve all relevant information about a specific element identified by its token ID. This includes the element's ID, name, selling price, owner address, and associated scientist ID. The function should be publicly accessible and provide this data in a structured format when queried with the specific token ID.",
        "url": 55
    },
    {
        "nl_input": "The query requires a mechanism to revert transactions when specific conditions are not met, ensuring operational integrity. It needs checks for valid states, such as whether wei is sent, if the sale has started, if the wallet is valid, if the sale is configured, and if it has already been finalized. The solution should include conditional statements to handle these scenarios appropriately.",
        "url": 56
    },
    {
        "nl_input": "The query requires a function to calculate the total payout amount by deducting commission and donation from the total bet amount. It involves determining commission and donation percentages, subtracting them from the total, and transferring the respective amounts to the owner and charity, while emitting events for these transactions.",
        "url": 57
    },
    {
        "nl_input": "The query requires a function to delete a transaction by a given key, ensuring the transaction exists before deletion. It involves managing transaction indices, updating related mappings, and maintaining policy counts. The solution should handle secure removal while preserving data integrity and emitting confirmation upon successful deletion.",
        "url": 58
    },
    {
        "nl_input": "The query requires an external function to add a new dungeon floor by its ID, allowing only contract owners to modify the dungeon state. The function should update the dungeon's floor number, creation time, rewards, and floor genes based on the provided parameters.",
        "url": 59
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens to be transferred to an investor's address based on the amount of ether invested. It involves determining a token rate and using it to compute the corresponding token amount for the given invested ether value. The function should take the invested ether amount as input and return the calculated token amount.",
        "url": 60
    },
    {
        "nl_input": "The query requires a function allowing the owner to authorize a crowdsale contract for token distribution. The desired functionality involves setting distributor addresses and their states, ensuring only the owner can perform this action, and emitting an event upon changes. It focuses on managing distributors and enabling token distribution through authorized contracts.",
        "url": 61
    },
    {
        "nl_input": "The query requires a function to create a request, assigning it a unique ID. It involves initializing request parameters such as type, target address, value, and message, while also emitting an event to notify of the request creation. The focus is on managing request IDs and storing relevant data for each request.",
        "url": 62
    },
    {
        "nl_input": "The query requires a function to assign an allowance value to a specified address (_spender), permitting it to use the balance of the message sender (msg.sender). The function should take two parameters: _spender (address) and _value (uint256), and return a boolean value indicating success. It involves setting allowances and emitting an approval event.",
        "url": 63
    },
    {
        "nl_input": "The query requires a function to handle the deposit of funds in a smart contract, ensuring that only authorized users can deposit wei, updating the user's token balance accordingly, and emitting an event to confirm the deposit. The solution should include a payable function with appropriate checks and balance updates.",
        "url": 64
    },
    {
        "nl_input": "The query requires a function to withdraw deposited funds. It should handle user deposits, verify withdrawal conditions, and transfer the appropriate amount back to the user. The solution must include functionality to check eligibility, update states if necessary, and ensure accurate fund distribution while maintaining security and correctness in the withdrawal process.",
        "url": 65
    },
    {
        "nl_input": "The query requires implementing a modifier in a smart contract that restricts function access to a single authorized payer. The modifier should check if the caller is listed as a valid payer and allow execution only if the condition is met, ensuring exclusive access control for authorized entities.",
        "url": 66
    },
    {
        "nl_input": "The query requires a function that allows the owner to transfer tokens from one address to another. The function should ensure that the transfer amount is valid, the transfer is within a specified time frame, and neither the sender nor the recipient is restricted by a specific condition (e.g., being in 'congress'). It involves invoking a token transfer method with appropriate validations.",
        "url": 67
    },
    {
        "nl_input": "The query requires a function to facilitate payment on behalf of the sender, involving a customer identifier (UUID v4). It should handle transactions by associating the payment with the sender's information and ensuring proper execution through a payable function. The solution must include parameters for customer identification and sender details while maintaining transaction integrity.",
        "url": 68
    },
    {
        "nl_input": "The query requires a function to add an address associated with \"Burning Man\" into a contract, ensuring it doesn't already exist, and verifying permissions through a multisignature process. The provided code examples demonstrate adding addresses with specific roles, utilizing modifiers for permission checks, and ensuring uniqueness before addition. The focus is on securely adding addresses with defined rights.",
        "url": 69
    },
    {
        "nl_input": "The query requires a function to add staff addresses to a whitelist. It involves iterating through a list of addresses, ensuring they are valid, and adding them to a whitelist mapping or array if not already present. The function should be accessible only to authorized users (e.g., admin or whitelister).",
        "url": 70
    },
    {
        "nl_input": "The query requires a function to freeze the account at a specific target address. The function should take the target address as an input parameter and set its status to frozen, preventing it from sending or receiving tokens. This action is typically restricted to authorized users, such as contract owners.",
        "url": 71
    },
    {
        "nl_input": "The query requires setting an address with the authority to approve users through KYC verification. This involves designating a trusted KYC provider, typically compliant with legal standards (e.g., Swiss law), by assigning their address in the contract. The function should be restricted to the contract owner for security and regulatory adherence.",
        "url": 72
    },
    {
        "nl_input": "The query requires a function to retrieve the price of registered assets in a specific format: (bool areRecent, uint prices, uint decimals). It should check if prices are recent within a validity interval, provide an array of prices, and include decimal places for each asset, avoiding floating numbers by using mul(price, 10 ** decimal).",
        "url": 73
    },
    {
        "nl_input": "The query requires a function to remove or cancel an auction associated with a specific item (e.g., deed or part ID). The solution should delete the auction entry, potentially transfer the item back to the seller, and possibly emit an event indicating the cancellation. It involves internal contract functions for managing auction states in a blockchain environment.",
        "url": 74
    },
    {
        "nl_input": "The query requires a function to retrieve the dividends of the owner, optionally including bonuses. It needs to handle dividend calculations for a specified recipient, considering both regular dividends and referral bonuses if applicable. The solution should involve a function that accepts an address and a boolean flag, returning the total dividend amount based on these parameters.",
        "url": 75
    },
    {
        "nl_input": "The query requires creating a new product contract, involving product ownership and related operations. It needs functionality to manage product details, ensure active participants, handle permissions, and possibly include fee transactions. The solution should involve struct definitions for Product, Brand, and App, along with functions to mark products and transfer fees securely.",
        "url": 76
    },
    {
        "nl_input": "The query requires a function to unpause a smart contract, allowing it to resume normal operations. This function should be callable only by authorized roles (e.g., Owner or Manager) and must ensure the contract is currently paused before execution. The solution involves setting the \"paused\" state variable to false and optionally emitting an event to log the action.",
        "url": 77
    },
    {
        "nl_input": "The query requires a function to allow anyone to contribute to the buy executer's reward. The desired function should be payable and increase the reward pool by the contributed amount. It should not restrict who can contribute, making it accessible for any user to add value to the reward system directly.",
        "url": 78
    },
    {
        "nl_input": "The query requires a function to handle donations for an event, specifying the event address and donation amount. The function should ensure the donation is transferred successfully, update the event's contribution record, and emit an event confirming the donation details. It must also include validation to confirm the transaction's success.",
        "url": 79
    },
    {
        "nl_input": "The query requires a function to add a new owner to a contract, ensuring the new owner address is valid and does not already exist. The function should update the list of owners and possibly trigger an event or assertion to confirm consistency and validity of the owner addition.",
        "url": 80
    },
    {
        "nl_input": "The query requires a function to check if the provided fee is sufficient based on predefined conditions. It involves comparing the sent value with the required fee, potentially throwing an error if insufficient, and ensuring the fee is processed correctly. The focus is on fee validation and handling within a smart contract environment.",
        "url": 81
    },
    {
        "nl_input": "The query requires a function to return the current game state, including details like player state, game ID, bet direction, bet amount, rolls, and winnings. It seeks a comprehensive view of an ongoing game for a specific player within a gaming contract context. The provided code snippets contain examples of functions that return game-related information.",
        "url": 82
    },
    {
        "nl_input": "The query requires a function to calculate the amount of WPX tokens received based on the input wei amount and predefined rates per 1 ETH. It needs logic to determine the token amount by multiplying the wei amount with the corresponding rate and may include tiered rate structures or specific divisions to convert wei to tokens accurately.",
        "url": 83
    },
    {
        "nl_input": "The query requires a function to pause and unpause an ICO, ensuring only the sender (owner) can execute these actions. The function should toggle the ICO's paused state, with appropriate access control to restrict usage to the owner. This ensures the ICO can be safely paused or resumed as needed.",
        "url": 84
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to close a sale, burning tokens associated with the sale and setting a boolean flag to indicate the sale is closed. The function should ensure only the owner can execute it and confirm the sale has not already been closed.",
        "url": 85
    },
    {
        "nl_input": "The query requires a function to add KYC'ed addresses to a whitelist. It needs to iterate through an array of addresses and mark each as whitelisted. The function should be accessible only to authorized users, ensuring security and compliance with KYC/AML regulations.",
        "url": 86
    },
    {
        "nl_input": "The query requires a modifier that allows specific actions to be executed by everyone. This involves implementing a condition to ensure that a particular function or set of functions can be accessed without restrictions, using a boolean variable to enable or disable the functionality for all users. The provided code demonstrates a similar concept with a customizable access control mechanism.",
        "url": 87
    },
    {
        "nl_input": "The query requires a mechanism to safeguard investors' funds by ensuring that locked amounts are released based on specific time conditions. If an investor's delivery date is in the future, the full amount remains locked; after 90 days, two-thirds are unlocked, and after 180 days, one-third remains locked. This ensures gradual access to funds post-investment.",
        "url": 88
    },
    {
        "nl_input": "The query requires a function to return the owner of a specific soul. The most suitable code should directly map an entity (soul) to its owner and return the owner's address. Specifically, it involves checking relationships or mappings that associate souls with their respective owners and providing the owner's address as the output.",
        "url": 89
    },
    {
        "nl_input": "The query requires a function to put a LinglongCat up for auction, specifying the cat ID, starting price, ending price, and auction duration. The code should ensure the sender owns the LinglongCat and it is not pregnant before approving and creating the auction.",
        "url": 90
    },
    {
        "nl_input": "The query requires a function to allocate tokens to a specified address. It should include parameters for the receiver's address and the amount of tokens, with optional features like UUID tracking for external payments. The function must ensure proper token assignment, maintain balance records, and possibly include security measures such as checks or modifiers to control execution.",
        "url": 91
    },
    {
        "nl_input": "The query requires a function that ensures tokens are either not yet released or have already been released, preventing actions during the release process. It involves a modifier or function checking the release state, allowing execution only before or after token release, ensuring proper timing for token-related operations.",
        "url": 92
    },
    {
        "nl_input": "The query requires a function to calculate and add bonuses based on investment tiers. Specifically, it needs logic to provide 125%, 100%, and 62.5% bonus rates for different token investment levels (1.5M, 1M, and 1M NTRY tokens, respectively). The solution should handle remaining token amounts and apply the appropriate bonus depending on the current investment tier.",
        "url": 93
    },
    {
        "nl_input": "The query requires a function to lock ERC721 behavior, enabling trading on third-party platforms. The desired functionality involves disabling or pausing ERC721 token transfers through a specific function, allowing control over trading. This ensures the contract can restrict or enable ERC721 behavior as needed for external platform compatibility.",
        "url": 94
    },
    {
        "nl_input": "The query requires a function to retrieve the address of the current smart contract. It needs a method that, when called internally, returns the contract's own address as output. This ensures the contract can identify and provide its unique address within the blockchain environment.",
        "url": 95
    },
    {
        "nl_input": "The query requires a function to set an alias for the msg.sender's address, allowing association of a string alias with the sender's address and storing both mappings (address to alias and alias to address) for future reference within a smart contract. The provided code snippet demonstrates this functionality.",
        "url": 96
    },
    {
        "nl_input": "The query requires a function to cast a vote for an account, ensuring the voter hasn't exceeded their vote limit and that the voting process adheres to specific rules (e.g., valid candidate, active voting period). The function updates vote counts and records voter details while enforcing constraints like unique voting per account and sufficient voting balance.",
        "url": 97
    },
    {
        "nl_input": "The query requires a function to lock a specific address until a specified time. It needs parameters for the target address and the lockup duration, ensuring the new lock time is later than any existing one. The function should also emit an event indicating the lockup details upon successful execution.",
        "url": 98
    },
    {
        "nl_input": "The query requires identifying the restriction that only specific contracts (KittyGym and Arena) can modify the KittyData. The description should highlight this permission control mechanism, ensuring that modifications to KittyData are limited to authorized contracts for security and integrity purposes. This limitation is enforced through a modifier checking the sender's address against predefined contract addresses.",
        "url": 99
    },
    {
        "nl_input": "The query requires a function to set the enabled status of an account. The function should take an account address and a boolean value as parameters, updating the account's enabled status accordingly. It must ensure proper authorization and validation before modifying the account status. This functionality allows for controlling account activation or deactivation within a system.",
        "url": 100
    },
    {
        "nl_input": "The query requires a function to send a specified value to the next investor(s) in a list. It involves iterating through a list of investors, deducting the value from their balances, and sending it to their address. If the balance is insufficient, it moves to the next investor until the entire value is distributed or the list ends.",
        "url": 101
    },
    {
        "nl_input": "The query requires changing the treasury address, which is the destination for forwarded payments. The code should include a function to set a new treasury address, ensuring payments are directed to the updated location. This involves modifying the contract to accept and update the treasury address while maintaining payment forwarding functionality.",
        "url": 102
    },
    {
        "nl_input": "The query requires a helper function implementation. Based on the provided code snippets, the requirement seems to be for a function that either retrieves information (e.g., `getMyInfo` or `getPlayerInfo`) or enforces specific conditions (e.g., `onlyOnce` modifier). The focus is on creating a utility function to support contract functionality, possibly involving state checks or value management.",
        "url": 103
    },
    {
        "nl_input": "The query requires a function to migrate token holders to a new contract, callable only by the owner when a migration agent is set. It involves transferring token balances from the old contract to the new one, updating total supply, and recording the migration progress until all holders are migrated.",
        "url": 104
    },
    {
        "nl_input": "The query requires storing the gas price as a storage variable for easy reference and updating it using an oraclize function. The solution involves setting the gas price via a function that accepts a uint256 parameter, stores it in a variable, and applies the change using the oraclize_setCustomGasPrice function, ensuring authorized access for modification.",
        "url": 105
    },
    {
        "nl_input": "The query requires a function to send tokens to a partner address. It needs to ensure that tokens are transferred only once, calculate the token amount based on a fraction of total supply, and update the state after emission. The function should involve partner-specific token allocation and utilize an emit or transfer method for token distribution.",
        "url": 106
    },
    {
        "nl_input": "The query requires a function to self-register a new DIN (Digital Identity Number) and set the resolver address. The function should take the resolver's address as a parameter and return the registered DIN. It involves interacting with a registrar system, where the DIN is associated with the sender's address and the specified resolver.",
        "url": 107
    },
    {
        "nl_input": "The query requires an internal function for transferring ownership of a team, specifying the original owner, new owner, and team ID as parameters. It involves updating ownership counts and records, ensuring the original owner is not a zero address, and emitting a transfer event with relevant details.",
        "url": 108
    },
    {
        "nl_input": "The query requires a function that sets a parameter identified by a given name to a specified value. The function should take the name of the parameter and its value as inputs and store them using a hashing mechanism (e.g., keccak256). It needs to be implemented as a private function within a smart contract.",
        "url": 109
    },
    {
        "nl_input": "The query requires a function to set or update the token address within a contract, ensuring it can only be executed by authorized entities (e.g., founder or owner). The function should accept an address parameter, validate it if necessary, and assign it to a contract variable representing the token. Some versions also include checks to ensure the token is not already deployed.",
        "url": 110
    },
    {
        "nl_input": "The query requires a function to manually perform a health check, potentially adjusting a maintenance mode and triggering the health check based on the mode's value. It should include logic to determine whether to execute the health check depending on the specified maintenance mode range.",
        "url": 111
    },
    {
        "nl_input": "The query requires a function to set a new token wallet address, ensuring the address is valid and not zero. It should restrict changes to authorized users (e.g., owners or founders) and may include event logging or additional checks to prevent conflicts with existing addresses or contracts. The function must update the token wallet address accordingly.",
        "url": 112
    },
    {
        "nl_input": "The query requires a function to check if a given address is registered. The function should return a boolean value, true if the address is registered, and false otherwise. It involves verifying the existence or status of an address within a predefined list, mapping, or record system in a smart contract environment.",
        "url": 113
    },
    {
        "nl_input": "The query requires a function to return the current total supply of tokens. It should be publicly accessible, constant, and return a uint256 value representing the total token supply. The function is typically named \"totalSupply\" and is part of a contract.",
        "url": 114
    },
    {
        "nl_input": "The query requires a function to add a minter to the TAU token contract after deployment. It needs a method that accepts an address, verifies it, adds it to the minters' list, and confirms the operation's success, ensuring only authorized entities can mint tokens.",
        "url": 115
    },
    {
        "nl_input": "The query requires a function to transfer shares (tokens) to another address, ensuring the sender has sufficient balance and emitting a transfer event. It should also comply with the Ethereum EIP-20 standard, involving balance updates and possibly shareholder management without transferring contract ownership.",
        "url": 116
    },
    {
        "nl_input": "The query requires a function to close a fund when specific conditions are met, such as the balance being below a minimum threshold. It involves transitioning the fund's state to \"Closed,\" emitting an event, and transferring the remaining balance to a specified wallet (e.g., teamWallet). The focus is on securely finalizing the fund and ensuring proper fund distribution or refund logic if goals aren't met.",
        "url": 117
    },
    {
        "nl_input": "The query requires a function to distribute tokens to specified addresses. It involves transferring token amounts based on predefined rules, ensuring the sender is authorized, and checking the available supply. The distribution may involve multiple recipients, calculated ratios, or activating a distribution phase for token claiming. The process includes updating balances and emitting events for transparency.",
        "url": 118
    },
    {
        "nl_input": "The query aims to collect all fees paid till now. It requires a function that accumulates fees, possibly from multiple transactions, and stores them for later retrieval or distribution. The solution should involve tracking fees associated with specific addresses and ensuring accurate accounting of fee amounts over time.",
        "url": 119
    },
    {
        "nl_input": "The query requires a function to update the token fee for approving a transfer. It needs a method that sets a new fee, likely involving parameters such as the fee amount and ensuring proper event logging or validation. The function should modify the existing fee and confirm the change successfully.",
        "url": 120
    },
    {
        "nl_input": "The query requires a function to burn tokens from the sender's balance, ensuring the sender has sufficient tokens and adjusting the balance and total supply accordingly. The most relevant code implements a `burnFrom` function, which checks the sender's balance and allowance, deducts the specified token amount, updates the total supply, and emits a `Burn` event.",
        "url": 121
    },
    {
        "nl_input": "The query seeks a generic substitution for the `require()` function, which is used to enforce conditions in modifiers within Solidity smart contracts. The provided code examples demonstrate different uses of `require()`, such as checking operational status, release timing, and lock status. The requirement is to replace `require()` with an alternative that achieves similar conditional enforcement.",
        "url": 122
    },
    {
        "nl_input": "The query requires a public getter function that retrieves specific information related to an action mapping, which isn't functioning in web3.js. The required function should allow access to details such as confirmations, expiration, triggered status, target address, and eth value associated with a given action ID in a smart contract context.",
        "url": 123
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to remove a target address from the blacklist. The desired functionality should include an external function with the ability to modify the blacklist status of a given address, specifically setting it to false, ensuring only the contract owner can perform this action.",
        "url": 124
    },
    {
        "nl_input": "The query requires a helper method that retrieves token details, including name, symbol, and totalSupply, in a single function call. The desired implementation should return these values as a tuple or similar structure for efficient access to the token's metadata and supply information.",
        "url": 125
    },
    {
        "nl_input": "The query requires a function that calculates the withdrawable amount of tokens for a given address based on specific conditions, including time stakes and token balances. It involves iterating through stake types (DAY, WEEK, MONTH), checking maturity based on current time, and computing amounts eligible for withdrawal using a calculator function. The result is the total withdrawable token amount.",
        "url": 126
    },
    {
        "nl_input": "The query requires a function to retrieve the stake actualAmount for active personal stakes associated with a specific address. It needs to accept an address as input and return an array of uint256 representing the actual amounts of stakes. The solution should involve accessing stored stake data and returning the relevant amounts for the given address.",
        "url": 127
    },
    {
        "nl_input": "The query requires a function that allows a whitelisted internal application to set the ICO end date, ensuring it can only be used once. The function should check if the ICO end date is already set and, if not, set it to the provided date. This ensures control over the ICO timeline with restricted access and one-time usage.",
        "url": 128
    },
    {
        "nl_input": "The query requires a function to set a controller address, ensuring the operation is authorized and the controller can only be set if attaching is enabled. The function should emit an event indicating the new controller has been set, allowing for proper tracking and notification of the change.",
        "url": 129
    },
    {
        "nl_input": "The query requires a function to set the share cut percentage for the contract owner, charged to the seller upon a successful sale. It needs a parameter for the share amount (0-100) and ensures the value is less than 100 before updating the owner's cut and emitting an event.",
        "url": 130
    },
    {
        "nl_input": "The query requires updating the address of an access manager. The relevant code should include a function that allows modifying the access manager's address, ensuring it is non-zero and possibly restricted to contract owners or authorized entities. The function must confirm successful execution and may involve event logging for transparency.",
        "url": 131
    },
    {
        "nl_input": "The query requires generating a giant cat image using pixel data. The code should define an array of bytes representing the cat's image and manipulate pixel rows to create a consistent pattern across the image. The result is a visual representation of a cat constructed from hexadecimal pixel values.",
        "url": 132
    },
    {
        "nl_input": "The query requires a function to retrieve the commitment amount associated with a specified address. The needed code should take an address as input and return the corresponding commitment value, as stored in a mapping or similar data structure within the contract. This involves accessing the stored commitment for the given address and returning it.",
        "url": 133
    },
    {
        "nl_input": "The query requires a function to change the wallet address for reserved vesting, allowing the setting of a smart-contract address at a later time. It needs an input parameter for the new wallet address and should include ownership restrictions to ensure only the owner can modify the wallet.",
        "url": 134
    },
    {
        "nl_input": "The query requires a function to create or update a personal claim with key-value pairs. It should allow users to set claims about themselves, using a structure that associates a key (bytes32) with a value (bytes32). The solution must enable updating or creating claims via a public function for the user's address.",
        "url": 135
    },
    {
        "nl_input": "The query requires a function to check if a user belongs to a specific group. It needs a boolean return indicating whether the given user address is part of the specified group name, involving user registration verification and mapping between users and group names.",
        "url": 136
    },
    {
        "nl_input": "The query requires a function to transfer any accidentally sent ERC20 tokens to the owner's address. The function should be accessible only by the owner and accept the token address and amount as parameters, returning a boolean indicating success. It must ensure the contract cannot transfer its native tokens.",
        "url": 137
    },
    {
        "nl_input": "The query requires a function that always returns 0 for the amount of remaining tokens allowed to be spent. This is typically represented by an allowance function in smart contracts, where the approved token amount for transfer is concerned. The focus is on implementing this functionality to consistently return zero regardless of owner or spender details.",
        "url": 138
    },
    {
        "nl_input": "The query requires a function to forward payment from the sender's address to a specified recipient ('to') after deducting a fee. The function should ensure the recipient is valid, check the payment amount, update balances and total supply accordingly, and finally transfer the remaining amount to the recipient.",
        "url": 139
    },
    {
        "nl_input": "The query requires a function to add an address to an accredited list, specifying details like cliff, vesting period, revokability, burning on revoke, minimum and maximum investment limits. The function should validate inputs and associate the address with these parameters, potentially emitting an event upon successful addition.",
        "url": 140
    },
    {
        "nl_input": "The query requires a function to unpause token transfers, ensuring the token contract resumes normal operations. It needs to be callable by the owner of the ICO contract, which owns the token contract. The solution involves invoking the `unpause` function on the token contract through the ICO contract to enable token transfers.",
        "url": 141
    },
    {
        "nl_input": "The query requires a function to freeze multiple addresses, preventing them from sending or receiving tokens. It needs a list of target addresses and a boolean or timestamp to define the freeze status. The function should iterate through the addresses, apply the freeze status, and emit an event confirming the action. Only the owner can execute this function.",
        "url": 142
    },
    {
        "nl_input": "The query requires a function to create Tubers with specified attributes, including name, owner address, and price. The relevant code defines a private function _createTuber, which creates a Tuber object, assigns it a unique ID, sets its price, emits a Birth event, and transfers ownership to the specified address. This function meets the requirement for creating Tubers with the given parameters.",
        "url": 143
    },
    {
        "nl_input": "The query requires identifying a function that returns the number of decimal places used by a token. The relevant code is a contract function named `tokenDecimals`, which returns the value of the `decimals` variable, indicating the token's decimal precision. Other functions in the provided code are unrelated to this specific requirement.",
        "url": 144
    },
    {
        "nl_input": "The query requires a function to handle the redemption of MTU tokens. It needs to check if the user has applied units, allow redemption before a time limit, calculate and transfer the equivalent ether value based on a redemption rate, or return tokens if not redeeming. The function should also update redeemed and unredeemed token counts accordingly.",
        "url": 145
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on the wei input, following a specific rate or course. It needs a method that takes wei as input and returns the corresponding token amount, potentially adjusting for different rates depending on the wei value or using a predefined course for conversion.",
        "url": 146
    },
    {
        "nl_input": "The query requires implementing logic to handle contribution amounts and caps for addresses. It involves setting contribution limits based on levels, updating minimum contributions, and managing how much an address can contribute within set caps. The solution should ensure contributions are processed accurately and emit events when soft or hard caps are reached.",
        "url": 147
    },
    {
        "nl_input": "The query requires a function to update the token symbol in a smart contract. The desired functionality should allow the contract owner to modify the symbol, either through a dedicated update function accepting a new symbol as a parameter or by setting it directly. It must also ensure proper authorization and potentially emit an event notifying of the change.",
        "url": 148
    },
    {
        "nl_input": "The query requires a method to list all deeds without using arrays, serving as an alternative to ERC721Enumerable. It needs a function that can iterate through deeds, identify owners, and return specific deed identifiers based on owner and index, ensuring efficient access to deed information without array manipulation.",
        "url": 149
    },
    {
        "nl_input": "The query requires implementing a function to change the owner of a contract to a new address specified by the parameter `_owner`. The function should ensure only the current owner can invoke it, update the owner's address, and optionally emit an event to log the ownership transfer.",
        "url": 150
    },
    {
        "nl_input": "The query requires a function that allows the owner to mint new tokens, specifying the recipient address and the amount to be minted. The selected code should ensure proper validation, update token balances and total supply, and emit relevant events to confirm the minting process successfully.",
        "url": 151
    },
    {
        "nl_input": "The query requires a function to set or update the token address within a smart contract, ensuring only authorized users (e.g., founder/owner) can modify it. The function may include validation (e.g., non-zero address, token not already deployed) and typically accepts an address parameter, assigning it to a contract's token variable.",
        "url": 152
    },
    {
        "nl_input": "The query requires an internal method to create a new EtherDog by specifying its attributes (matron ID, sire ID, generation, genes, and owner). The method validates inputs, initializes the EtherDog's properties, adds it to storage, emits a birth event, and transfers ownership to the designated address. It ensures proper data type constraints and handles cooldown logic based on generation.",
        "url": 153
    },
    {
        "nl_input": "The query requires a function to transfer all raised funds to the founder's wallet after the ICO ends. It needs to ensure that the transfer occurs only when the ICO has concluded and should be accessible exclusively by the owner for security and proper fund management.",
        "url": 154
    },
    {
        "nl_input": "The query requires a function to close betting on a champion by specifying the champion ID. The function should set the winning choice, close the bet, calculate the reward, and log the winning details. It involves managing bets, ensuring they are not duplicated, and handling betting prices and match IDs. The solution must integrate these functionalities seamlessly.",
        "url": 155
    },
    {
        "nl_input": "The query requires identifying code that handles urgency situations, likely involving time-sensitive conditions or critical actions. The relevant code should include modifiers or functions that ensure operations are performed within specific timeframes or under urgent conditions to maintain contract integrity and security.",
        "url": 156
    },
    {
        "nl_input": "The query requires a function for administrators to add claimants, specifying their address and claim amount. The selected code should allow an admin to create a new claimant entry, storing the claimant's address, claim amount, and initial claim status as false. This functionality supports managing claimants in a structured array or list within a smart contract.",
        "url": 157
    },
    {
        "nl_input": "The query requires a function to place bets on dozens in a roulette-like game. The function should accept an input (0, 1, or 2) representing the first, second, or third dozen, respectively. It must validate the input and place the bet accordingly, ensuring the selected dozen is within the allowed range.",
        "url": 158
    },
    {
        "nl_input": "The query requires a mechanism to ensure the signature is valid for certified basic accounts with a sufficiently low gas price and high transaction value. It involves verifying user eligibility based on geographical certification, account type, and transaction constraints, potentially incorporating KYC checks and signature validation to confirm the sender's address and transaction limits.",
        "url": 159
    },
    {
        "nl_input": "The query requires an internal function for loan repayment, assuming the repayment amount is already transferred. It involves validating the loan ID, state, repayment amount, and maturity date. The function updates the loan state, calculates loan and interest amounts, handles token transfers and burns, notifies supervisors, and returns collateral upon successful repayment.",
        "url": 160
    },
    {
        "nl_input": "The query requires a function that can be overridden by test mocks. It should serve as a placeholder or assertion mechanism in testing environments, allowing for custom behavior during tests. The extracted information indicates a need for a private pure function to compare values and potentially revert if conditions aren't met, facilitating test assertions.",
        "url": 161
    },
    {
        "nl_input": "The query requires a function to retrieve the enemy combination associated with a specific address. It should check if the combination is personalized; if not, it uses an initial enemy combination and returns the enemy slot class IDs as a result.",
        "url": 162
    },
    {
        "nl_input": "The query requires a function to read player metadata for migration, accessible only by the contract owner. It should retrieve details like player ID, name, address, scores (confirmed and unconfirmed), and activity status, facilitating data migration while ensuring security through ownership verification.",
        "url": 163
    },
    {
        "nl_input": "The query requires a function to determine the current halving number based on block information. Specifically, it needs a method that calculates and returns the current halving phase using blockchain data, ensuring it adheres to predefined rules or intervals for halving events. This involves identifying the correct block-based computation logic from the provided code.",
        "url": 164
    },
    {
        "nl_input": "The query requires a function allowing the crowdsale owner to withdraw any specified amount of ether from the contract at any time. The function should ensure the contract has sufficient balance before transferring the requested amount to the owner's address. It may also include splitting the withdrawal to multiple addresses or withdrawing the entire balance.",
        "url": 165
    },
    {
        "nl_input": "The query requires a function to convert a uint256 WSIC value into a warship structure. The needed code should define a Warship object by extracting specific bits from the WSIC value, organizing them into fields such as uint128, uint32, multiple uint8, and uint16 segments. This involves bitwise operations for data extraction and structuring.",
        "url": 166
    },
    {
        "nl_input": "The query requires a function that only the owner can execute to deliver tokens to ICO investors. It should include parameters for the recipient's address and the quantity of tokens to be delivered, ensuring proper token distribution during an Initial Coin Offering (ICO). The function must restrict access to the owner for security and control.",
        "url": 167
    },
    {
        "nl_input": "The query requires a method to signal a vote for a given candidate. The method should ensure the candidate is valid, handle voter eligibility, and record the vote accurately. It may also include constraints like voting periods or preventing multiple votes from the same account. The solution should be implemented within a smart contract environment.",
        "url": 168
    },
    {
        "nl_input": "The query requires a function to calculate the total amount of pending bets in a betting system. The relevant code should iterate through a list of bets, check their states (e.g., waiting for pairing or oracle response), and accumulate the corresponding bet prices. The result is the sum of all pending bet amounts.",
        "url": 169
    },
    {
        "nl_input": "The query requires setting the address of a smart contract to delegate execution of specific methods. It involves a function that accepts an address parameter, checks authorization, updates the delegate address if different, and emits a delegation event. The requirement focuses on managing delegation for method execution within smart contracts.",
        "url": 170
    },
    {
        "nl_input": "The query requires implementing a Digix price feed system. It needs a function to set the price feed with parameters like blockNumber, nonce, ask/bid prices, and signature verification (v, r, s). The function should ensure the new nonce is greater than the previous one, validate block numbers, and verify the signature. Finally, it encodes and updates the price feed.",
        "url": 171
    },
    {
        "nl_input": "The query requires a function to transfer ownership of an estate from one address to another. It needs parameters for the previous owner's address, new owner's address, and the token ID. The function should verify token existence, update ownership details, clear approvals, and ensure the new owner's address is valid.",
        "url": 172
    },
    {
        "nl_input": "The query requires an internal utility function to conclude a PVE battle, assuming all finish conditions are already verified. It should reset warrior actions, update cooldowns, potentially increase dungeon levels, handle arisen warriors, and emit a PVEFinished event, all while being restricted for internal use only.",
        "url": 173
    },
    {
        "nl_input": "The query requires a function to retrieve the token balance of a specific user at a particular block. It needs parameters for the user's address and target block number, returning the balance of tokens for that user on the specified block. The function should interact with a token contract method like 'balanceOfAt' to achieve this functionality.",
        "url": 174
    },
    {
        "nl_input": "The query requires a function to mint tokens for pre-crowdsale purchases before the crowdsale starts. It needs to take the purchaser's address and the number of tokens purchased as parameters, ensure the transaction occurs before the crowdsale start time, and verify that the total supply does not exceed the pre-crowdsale cap.",
        "url": 175
    },
    {
        "nl_input": "The query requires an ERC20 transfer function modified to allow transfers only after the sale has been finalized. This involves implementing a condition to check if the sale is finalized before executing the transfer, ensuring tokens cannot be moved until this condition is met. The solution should integrate a boolean flag or similar mechanism to track the sale finalization status.",
        "url": 176
    },
    {
        "nl_input": "The query requires a function to calculate a rate based on a base rate and a bonus percentage. The calculation should follow the formula: rate = baseRate * (100 + bonus) / 100. The function needs to consider additional bonuses depending on certain conditions and return the final calculated rate as a uint256 value.",
        "url": 177
    },
    {
        "nl_input": "The query requires a description of bonus rates for token investments. Investors receive additional percentages based on the number of tokens: 125% for the first 1.5 million NTRY, 100% for the next 1 million, and 62.5% for the final 1 million tokens. The description outlines a tiered bonus structure tied to the quantity of tokens invested.",
        "url": 178
    },
    {
        "nl_input": "The query requires an internal utility function to initiate a PVP battle, assuming all battle requirements are pre-validated. It should handle the battle process internally without additional checks, likely involving warrior data and battle outcomes, while interacting with related contract functions for reward distribution or battle progression.",
        "url": 179
    },
    {
        "nl_input": "The query requires a code implementation that ensures a function can only be called once. This involves using a modifier to restrict the function's execution to a single call, typically employing a boolean or counter variable to track whether the function has already been executed. The provided code examples demonstrate various approaches to implementing such functionality.",
        "url": 180
    },
    {
        "nl_input": "The query requires a function to accept contributions only if the KYC (Know Your Customer) process is successfully passed. The requirement involves setting contribution caps based on KYC levels or approving/disapproving users' KYC status to manage contributions accordingly.",
        "url": 181
    },
    {
        "nl_input": "The query requires a function to modify the minimum bet amount, ensuring it is greater than zero and can only be changed by an authorized user (e.g., owner or management). The function should accept a new minimum value as a parameter and update the existing minimum bet amount if the conditions are met.",
        "url": 182
    },
    {
        "nl_input": "The query requires a function to retrieve a specific amount of tokens for a given address, ensuring the retrieval is authorized and the balance is sufficient. The function should adjust balances accordingly, emitting events for the retrieval and transfer actions.",
        "url": 183
    },
    {
        "nl_input": "The query requires a function to retrieve gift IDs based on a specified template ID. The needed code should map template IDs to corresponding gift IDs and return them as an array. Specifically, it involves a mapping structure that associates template IDs with gift IDs and a function to access this data efficiently.",
        "url": 184
    },
    {
        "nl_input": "The query requires a function to be executed after the crowdsale ends, ensuring finalization tasks such as forwarding funds or enabling refunds. It must verify conditions like the crowdsale's end time, goal achievement, and current state before performing actions like transferring balances or enabling refunds, and it should emit relevant events.",
        "url": 185
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens to be sent to a buyer based on the amount of ether provided and a predefined rate set during deployment. This involves multiplying the ether amount by the rate to determine the corresponding token amount for the transaction.",
        "url": 186
    },
    {
        "nl_input": "The query requires a function to run a distillation process, which involves transferring and burning tokens based on specific conditions. It needs to handle token allowances, transfer tokens from the sender to the contract, burn them, and distribute new tokens to the sender in return, depending on the source and target token configurations.",
        "url": 187
    },
    {
        "nl_input": "The query requires a function to fortify multiple previously claimed tiles in a single transaction. It involves verifying the amount, using battle value if specified, and applying the fortification to the selected tiles. The function should handle payable transactions and ensure the caller is not a contract.",
        "url": 188
    },
    {
        "nl_input": "The query requires a function to process purchases during a private sale, accepting wei amount and beneficiary address as inputs. It ensures the sale stage is private, calculates tokens based on the wei amount, and handles cases where the token pool is insufficient by adjusting the purchase and transitioning to the next sale stage while returning excess wei to the beneficiary.",
        "url": 189
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the owner's account to another account, with the restriction that only an escrow can initiate the token transfer for private sales. The function should ensure proper authorization, validate the transfer amount, and execute the token transfer while adhering to defined conditions and restrictions.",
        "url": 190
    },
    {
        "nl_input": "The query requires creating a new poll with specified parameters, such as title, vote quorum, commit duration, and reveal duration. The solution should include initializing the poll, setting its properties, and emitting an event to notify about the poll creation while ensuring validity checks for parameters like percentage and non-duplication.",
        "url": 191
    },
    {
        "nl_input": "The query requires determining if the state variable \"dstWalletLMNO\" is set. This involves checking whether \"dstWalletLMNO\" has been assigned a non-zero address value, ensuring it is properly initialized before being used in operations such as token debiting. The relevant code should include a function or condition that confirms this setup.",
        "url": 192
    },
    {
        "nl_input": "The query requires implementing a mechanism to allow access to slots bankroll only after 60 days. This involves creating a time-lock feature where the bankroll address can only be utilized or modified after a 60-day waiting period, ensuring restricted access until the specified duration has passed.",
        "url": 193
    },
    {
        "nl_input": "The query requires a function to accept ERC-20 tokens approved by the user and provide RMC tokens in return. It needs a mechanism for transferring specified ERC-20 tokens from the contract to the user, ensuring proper approval and balance checks, while issuing corresponding RMC tokens as part of the transaction process.",
        "url": 194
    },
    {
        "nl_input": "The query requires determining the conditions and recipients for releasing a jackpot. It involves checking specific conditions (e.g., time-based or completion status) and transferring the jackpot balance to the appropriate recipient while potentially resetting or deleting related data. The focus is on ensuring correct logic for jackpot distribution based on predefined criteria.",
        "url": 195
    },
    {
        "nl_input": "The query requires a function to calculate the profit from selling a specified number of outcome tokens, considering factors like outcome token index, count, and minimum profit. It involves determining the profit by subtracting fees from the calculated outcome token profit, ensuring the profit meets the minimum requirement, and transferring the profit to the sender while updating the net outcome tokens sold.",
        "url": 196
    },
    {
        "nl_input": "The query requires assigning asset share tokens to the authors of winning bids. The process involves calculating shares and return amounts based on bid details, updating executed amounts, assigned shares, and final fundraising values. It ensures that each winning bidder receives their share tokens, updates investor balances, and emits an assignment event for tracking.",
        "url": 197
    },
    {
        "nl_input": "The query requires a function to calculate the available tokens for a specific address, considering different phases or conditions. It involves checking token allocations, applying percentages, and summing up available tokens based on predefined steps or phases. The function should be view-only, ensuring no state modifications, and return the total available tokens as a uint value.",
        "url": 198
    },
    {
        "nl_input": "The query requires a function to check the available inventory of a product using its ID. The needed code should take a product ID as input and return the available quantity of that product, as stored in the associated inventory data structure. This allows users to view how much of a specific product is currently available.",
        "url": 199
    },
    {
        "nl_input": "The query requires a function to mint tokens, specifying the recipient address and token ID. It ensures the recipient address is valid, updates token ownership, and emits a transfer event to record the minting process in the blockchain, following standard token minting practices.",
        "url": 200
    },
    {
        "nl_input": "The query requires a function allowing the reservation owner to either close the reservation early or extend its duration. This is useful for implementing manual controls, such as closing after reaching a specific amount or extending the time frame, trusting the owner's judgment to manage the reservation state appropriately.",
        "url": 201
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to change the lock period, with restrictions on the allowable range of values for the lock period. Specifically, the owner should be able to modify the lock duration within a defined limit, such as between 1 and 30 days.",
        "url": 202
    },
    {
        "nl_input": "The query requires a mechanism for the owner to return collected ETH to investors if the soft cap is not reached or KYC checks fail. This involves refunding investors' contributions and potentially draining excess Ether from the contract under specific conditions, ensuring compliance with set rules and security measures.",
        "url": 203
    },
    {
        "nl_input": "The query requires a function to cancel an auction, ensuring the seller or owner can stop the auction process. The function should verify permissions, remove the auction listing, transfer ownership if necessary, and emit an event notifying that the auction has been canceled. Specific parameters may include auction ID, item ID, or owner address for validation.",
        "url": 204
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to seed the Jackpot with Ether, updating the jackpot balance, and enabling the owner to retrieve the funds after the Jackpot is paid. It focuses on the seeding mechanism and ensuring the owner can recover the seeded amount when necessary.",
        "url": 205
    },
    {
        "nl_input": "The query requires a function to retrieve the sender's information. Specifically, it needs a contract function that returns details associated with the sender's address, such as their balance or player info. The most suitable code should directly involve msg.sender to fetch and return the required information in a readable format.",
        "url": 206
    },
    {
        "nl_input": "The query requires implementing the `tokenRecipient` interface, likely involving functions to set a token address and possibly claim tokens. The provided code snippets demonstrate setting a token address within a contract, ensuring it's only callable by authorized entities (e.g., owner or founder), and claiming tokens for the sender. The solution should include these functionalities while adhering to the `tokenRecipient` interface requirements.",
        "url": 207
    },
    {
        "nl_input": "The query requires a function to handle ETH backup withdrawal, ensuring correct transfer of funds to the appropriate address. It needs conditional checks for valid addresses, proper data length, and available withdrawal amounts. The solution should include transferring ETH while considering scale factors and emitting an event for successful withdrawals.",
        "url": 208
    },
    {
        "nl_input": "The query requires a function that allows the owner to change the address of the admin. It needs to include a parameter for the new admin address, ensure the address is valid, and update the admin address accordingly. The function should restrict access to the owner and may involve additional checks or event emissions.",
        "url": 209
    },
    {
        "nl_input": "The query requires a method to zero out mappings for sellers in a sale list, specifically targeting the seller's price and list mapping. It needs an internal function that resets these values for a given seller, ensuring their price is set to zero and their mapping is cleared, as demonstrated in the provided code examples.",
        "url": 210
    },
    {
        "nl_input": "The query requires a function to transfer land ownership represented by coordinates (x, y) to a specified address. The relevant code should encode the land's coordinates into a token ID and transfer it to the target address, as seen in the first code snippet where the `transferLand` function calls `encodeTokenId` and transfers the resulting token.",
        "url": 211
    },
    {
        "nl_input": "The query requires a function that allows the owner to conclude the loyalty phase and initiate the presale phase, using block numbers for timing. The desired function should disable the loyalty part and record the current block number as the start of the presale.",
        "url": 212
    },
    {
        "nl_input": "The query requires a function that performs housekeeping by removing the contract from the blockchain, typically after an upgrade or when no longer needed. It should include a security measure restricting access to authorized entities (e.g., owner or specific address) and may involve conditions like contract state or time constraints before execution.",
        "url": 213
    },
    {
        "nl_input": "The query requires a function to add a new manager, specifying the manager's address. The function should ensure only valid and unique addresses are added, possibly involving access control (e.g., onlyOwner). It may include event logging for tracking changes or enabling/disabling managers. The solution must meet these criteria while ensuring proper validation and state updates.",
        "url": 214
    },
    {
        "nl_input": "The query requires a function to stake tokens from the caller for a specific user and reward that user with credits. It needs to handle token transfer, ensure a minimum stake amount, and optionally include data in the event log. The solution must also update credit balances and potentially lock stakes for a duration.",
        "url": 215
    },
    {
        "nl_input": "The query requires a modifier to verify if a value can be stored in a 64-bit unsigned integer. It ensures the value remains unchanged when cast between uint256 and uint64, using a require statement to validate this condition before allowing further execution. Only the first code snippet meets this requirement by defining the fitsIn64Bits modifier.",
        "url": 216
    },
    {
        "nl_input": "The query requires a function to initialize betting data, including parameters like ticket price and bet title. It should set up the initial configuration for a betting system, allowing an admin to define key aspects of the bet. The most relevant code demonstrates initializing bet data with specific values provided by the admin.",
        "url": 217
    },
    {
        "nl_input": "The query requires a function to submit a ring for validation and settlement in a blockchain-based trading system. It involves verifying input data, tokens, signatures, assembling orders, and handling the ring with specified fees and miners. The function ensures data integrity and proper execution of the ring submission process.",
        "url": 218
    },
    {
        "nl_input": "The query requires a default approval function that allows a user to approve another address to spend a specified amount of tokens on their behalf. The function should take the spender's address and the amount as parameters, update the allowance, emit an Approval event, and return a boolean indicating success.",
        "url": 219
    },
    {
        "nl_input": "The query requires a mechanism for backers to receive refunds when the MIN_CAP is not reached. This involves approving the transfer of Devvote tokens, calling a refund function in the DevvotePrefund contract, and withdrawing payments in ETH. The process ensures that backers can reclaim their contributions by executing specific contract functions in sequence.",
        "url": 220
    },
    {
        "nl_input": "The query requires a function to retrieve the X and Y coordinates of the curve point for a public key associated with an ENS node. Specifically, it needs a method that accepts an ENS node as input and returns the corresponding public key's X and Y coordinates, as defined in EIP 619.",
        "url": 221
    },
    {
        "nl_input": "The query requires a function to return the current Cap value. The needed code should have a function that directly provides the current Cap without additional parameters or computations. It must be straightforward, returning the Cap as a uint256 value when called. Among the provided options, the best match involves a simple return statement for the Cap.",
        "url": 222
    },
    {
        "nl_input": "The query requires a function to set or update the status of an ICO based on specific conditions, such as token availability or time constraints. It involves managing different ICO stages (PrivateICO, PreICO, ICO) and transitioning statuses (Active, Waiting, Closed) according to sold tokens or timestamps. The desired functionality should handle these transitions internally.",
        "url": 223
    },
    {
        "nl_input": "The query requires extracting the contract constant `_symbol`. The focus is on a function that returns the `_symbol` of a contract. It should provide a way to retrieve the symbol value without modification, ensuring it remains constant and accessible for external use. The implementation must align with the functionality of returning a predefined symbol string.",
        "url": 224
    },
    {
        "nl_input": "The query requires a function to assign a token address into a variable, callable only by the founder and executable only once. It ensures the token address is set securely and irreversibly within the contract, preventing multiple assignments and unauthorized access. The function should return a boolean value confirming successful execution.",
        "url": 225
    },
    {
        "nl_input": "The query requires a function to return the registered EOS public key for a given address. The relevant code should take an address as input and output the corresponding EOS public key string, either directly from stored records or by querying an external source if not found locally.",
        "url": 226
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another on behalf of the sender, ensuring the transaction amount does not exceed the allowed limit. It needs parameters for the sender's and recipient's addresses and the transaction value, with a return value indicating success. The function should adjust balances and allowances accordingly.",
        "url": 227
    },
    {
        "nl_input": "The query requires a function to facilitate batch approval for multiple spenders. It needs to ensure that none of the spender addresses are zero and should approve or disapprove all specified spenders in one operation, using a boolean parameter to indicate approval status. The function must support batching and interact with an approval mechanism.",
        "url": 228
    },
    {
        "nl_input": "The query requires a function to burn all remaining tokens in the owner's account and set the license cost, callable only once by the contract owner, with parameters for numerator and denominator to define the percentage of total supply as the license cost.",
        "url": 229
    },
    {
        "nl_input": "The query requires creating a new proposal to assign tokens to a beneficiary address, including parameters for the wallet address and token amount. It ensures validity checks (non-zero wallet, positive amount) and handles voting/quorum logic. If successful, it mints tokens to the beneficiary and manages emission balances. Otherwise, it initializes a new proposal.",
        "url": 230
    },
    {
        "nl_input": "The query requires a function that returns the number of matches recorded in the contract. It needs a public view function with no parameters, which outputs a uint representing the count of matches or games stored in the contract's state variable (e.g., matches.length or games.length).",
        "url": 231
    },
    {
        "nl_input": "The query requires a function that allows the release of FT tokens to core team accounts. The function should be callable by authorized entities and ensure proper token transfer after meeting specific conditions, such as release time or ownership validation. It involves managing locked tokens and enabling their movement to designated accounts.",
        "url": 232
    },
    {
        "nl_input": "The query requires calculating the offset of a given block within a halving interval. It needs a function that takes a block number as input and returns the offset by performing a modulo operation with the subsidy halving interval. The relevant code provides this functionality using the `blockOffset` function, which computes the remainder of the block number divided by the subsidy halving interval.",
        "url": 233
    },
    {
        "nl_input": "The query requires a function to set the expiry time using a timestamp in milliseconds since 1970. The needed code should include a function that accepts a parameter for the timestamp, updates the expiry time, and may involve access restrictions (e.g., onlyOwner). It should directly handle milliseconds and potentially emit an event upon execution.",
        "url": 234
    },
    {
        "nl_input": "The query requires a function to remove a contract address from the list of active contracts. It needs to take an address as a parameter and ensure that the address is removed correctly from the active list, likely adjusting indices or mappings to maintain data integrity after removal.",
        "url": 235
    },
    {
        "nl_input": "The query requires a function to change the ownership of a product. It needs to ensure a secure transfer by verifying the new owner's address and updating the ownership information accordingly, minimizing risks associated with transferring ownership to invalid addresses. The solution should involve a two-phase handover process for enhanced security.",
        "url": 236
    },
    {
        "nl_input": "The query requires a function to set a new wallet address, ensuring the address is valid and not zero. It should be callable only by the owner and may include additional checks or event emissions to confirm the update. The function must allow flexibility for future wallet changes while maintaining security constraints.",
        "url": 237
    },
    {
        "nl_input": "The query requires a failsafe mechanism to remove a game, transferring tokens to a specified address. It involves unlocking game-related data, updating locked amounts, and resetting game status while ensuring only the owner can perform this action. The provided code includes a manual game removal function that satisfies these requirements.",
        "url": 238
    },
    {
        "nl_input": "The query requires a function to retrieve the owner of a specific token. The most relevant code provides a `viewOwner` function that returns the address representing the owner of the token. It directly fulfills the requirement by returning the owner's address without additional complexities like token balances or lists.",
        "url": 239
    },
    {
        "nl_input": "The query requires a function to determine if an entity is a user-created entity (using createUser()) or a virtual entity (using createVirtualEntity()). It should take an entity address as input and return a boolean value indicating the entity's creation method, ensuring the entity is active and properly resolved.",
        "url": 240
    },
    {
        "nl_input": "The query requires a function to buy tokens, specifically detailing the process of purchasing tokens with conditions such as sale status, non-paused state, and minimum value requirements. It involves calculating token amounts based on rates, ensuring cap limits, minting tokens, and transferring funds to an ether wallet.",
        "url": 241
    },
    {
        "nl_input": "The query requires a function allowing the owner to set a standard signature that redirects to a pre-signed function. It involves mapping a standard function signature to an implemented function signature, ensuring compatibility with potential future standards like ERC865, with specific function signatures predefined for redirection.",
        "url": 242
    },
    {
        "nl_input": "The query requires a function to retrieve the TOC price. It needs a public view function that returns a uint256 value representing the TOC price stored in a specific contract's market mapping. The function should be easily callable and provide the current price without modifying the state.",
        "url": 243
    },
    {
        "nl_input": "The query requires a function to cancel an order on the black market for selling a specific quantity of coke at a certain price. The function should identify and remove the corresponding offer from the market, ensuring the seller, quantity, and price match the specified parameters, and emit an event upon successful cancellation.",
        "url": 244
    },
    {
        "nl_input": "The query requires a function to retrieve the total lottery amount. It should return the balance available in the lottery contract, representing the total funds accumulated for distribution or payout. This involves accessing the contract's current balance without altering it.",
        "url": 245
    },
    {
        "nl_input": "The query requires functions related to game management in smart contracts. Specifically, it needs functions that can retrieve game details (address, description, URL, submitter, and time), get the total number of games, and check if a specific game is active. These functionalities allow for querying and managing games within a contract system.",
        "url": 246
    },
    {
        "nl_input": "The query requires a function to validate the contract relationship, ensuring it meets specific conditions. It needs a boolean return type to confirm if the relationship is valid or \"sane.\" The focus is on evaluating contract states or parameters to guarantee correctness and consistency, as demonstrated by functions like 'isFinalizerSane', 'isValidGift', or 'checkRequiredChange'.",
        "url": 247
    },
    {
        "nl_input": "The query requires a helper function for the UI to display the amount of ETH already contributed by a user. The function should take a user address as input and return the contribution amount associated with that address in a readable format for the UI.",
        "url": 248
    },
    {
        "nl_input": "The query requires a function to extract an address encoded as the first argument in transaction data. The solution should take a byte array as input, check if it contains a valid address, and return the address. It must handle cases where the byte array length is insufficient and use assembly for efficient address retrieval.",
        "url": 249
    },
    {
        "nl_input": "The query requires a function to determine whether a given Day-Index is a holiday or not. It involves checking the day index against predefined lists or ranges and returning a result indicating the holiday status. The provided code snippet 'getHolidayByIndex_' demonstrates this functionality by mapping day indices to specific lists for determination.",
        "url": 250
    },
    {
        "nl_input": "The query requires a function to check if a given address has already invested. It needs to iterate through a list of investors and return true if the address exists in the list, indicating the address is an investor. Otherwise, it should return false. The focus is on verifying the existence of an investor's address within a predefined collection.",
        "url": 251
    },
    {
        "nl_input": "The query requires a function to determine the current stage or round based on specific conditions, such as time or amount. It needs to calculate or identify the current stage by checking predefined parameters, like timestamps, block numbers, or total token sold, and return the corresponding stage or round information.",
        "url": 252
    },
    {
        "nl_input": "The query requires implementing a function to disallow authorized wallets from withdrawing funds to a specific address. It involves setting a mapping or similar structure to deny permissions for particular addresses, ensuring that funds cannot be transferred to unauthorized receivers. The focus is on managing access control for fund withdrawals.",
        "url": 253
    },
    {
        "nl_input": "The query requires a function to display timelock periods and their corresponding locked values associated with a specific address. It involves retrieving an array of lock times, adjusting them based on predefined earlier and later values, and returning these adjusted lock times for the given address. The focus is on presenting the time-related data tied to locking mechanisms.",
        "url": 254
    },
    {
        "nl_input": "The query requires a function allowing the registry owner to withdraw surplus value. The code should ensure only the owner can initiate the withdrawal, check if the balance is sufficient, and transfer the specified amount or entire balance to the owner. The solution must prevent reentrancy attacks and confirm successful transfers.",
        "url": 255
    },
    {
        "nl_input": "The query requires a function to set up or manage a whitelist, including adding addresses or enabling/disabling the whitelist state. It involves interactions with whitelist-related contracts or interfaces, ensuring only authorized users can modify the whitelist, and possibly emitting events for changes. The provided code highlights different aspects of whitelist management in smart contracts.",
        "url": 256
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a contract to a new Ethereum address. The function should ensure the new owner address is valid and update the ownership accordingly. It may also include an event notification for the ownership transfer and restrict access to the current owner only.",
        "url": 257
    },
    {
        "nl_input": "The query requires a function that allows the current collector to transfer contract control to a newCollector, specified by its address. The function should ensure the newCollector address is valid, emit an event indicating the transfer, and update the collector to the new address provided. This ensures proper transition of control within the contract.",
        "url": 258
    },
    {
        "nl_input": "The query requires a function that caps the reward amount to the minimum of three values: reward, balance, and daily limit remaining. It ensures the reward does not exceed the available balance or the remaining daily limit, returning the adjusted reward amount. The description focuses on limiting rewards based on these constraints.",
        "url": 259
    },
    {
        "nl_input": "The query requires a function to transfer superOwner authority to a new address, ensuring only the hiddenOwner can execute this change. The function should emit an event logging the role transfer and update the superOwner variable accordingly. It involves managing roles and permissions within a smart contract system.",
        "url": 260
    },
    {
        "nl_input": "The query requires a function enabling users to purchase Dragon Ball Z heroes. The function should handle price escalation after each purchase, ensure the contract is not paused, and manage payments including developer fees. It also needs to transfer ownership of the hero to the buyer and update the hero's current price accordingly.",
        "url": 261
    },
    {
        "nl_input": "The query requires a function to retrieve the amount of bronze caps produced so far. It needs a public view function named producedBronzeCaps, which returns a uint64 value representing the total number of bronze caps produced, extracted from a variable like packedProducedCaps.",
        "url": 262
    },
    {
        "nl_input": "The query requires a function to update the balances map and totalSupplyHistory. It needs to handle token supply updates, maintaining the balance mappings and recording changes in supply history for potential future reference or calculations in a blockchain-based token system. The provided code examples focus on total supply management but lack explicit updating mechanisms for balances and supply history.",
        "url": 263
    },
    {
        "nl_input": "The query requires a function that sets a score for a given address, including cumulative score and total ratings, returning success if completed successfully. It involves updating and storing score-related data for addresses in a structured format, ensuring the score's existence before modification.",
        "url": 264
    },
    {
        "nl_input": "The query requires a function to set the duration of time per period, specified in seconds, using an array input for different periods. The function should restrict access to authorized users (e.g., governors). It aims to configure the minimum time each period lasts, allowing flexible adjustment via the setter method.",
        "url": 265
    },
    {
        "nl_input": "The query requires a function that allows the owner to permit a specific address, such as a crowdsale contract, to transfer tokens even during a lock-up period. The function should take an address and a boolean state as parameters and update the transfer permission for that address accordingly.",
        "url": 266
    },
    {
        "nl_input": "The query requires a function to handle a game forfeiture by Player 1 when they know they have lost, updating game states, transferring values, and recording results without revealing moves. It involves managing game status, player balances, and ensuring proper state transitions upon forfeiture.",
        "url": 267
    },
    {
        "nl_input": "The query requires a function to clean up a game by setting it to inactive, refunding any balances, and ensuring it is only callable by the housekeep function. The desired function should iterate through players, refund their balances if active, set the game to inactive, and record the reason for ending. It must also handle failed refunds and log events accordingly.",
        "url": 268
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to modify the bonus percentage for the current phase of an ICO. It should accept a new bonus value as a parameter, verify if the change is valid, update the bonus for either Pre-ICO or Main ICO phases, and emit an event indicating the change.",
        "url": 269
    },
    {
        "nl_input": "The query requires a function to add a new animal type to the game with a maximum limit of 100 animal types. The cost for the new animal type must not be lower than the initial cost, and the function should only be accessible to the owner of the contract.",
        "url": 270
    },
    {
        "nl_input": "The query requires a modifier that ensures actions are only executable when the contract is not paused. This involves a condition checking the contract's paused state and allowing function execution only if the contract is active, typically using a boolean variable to track the pause status. The provided code examples demonstrate implementations of such functionality.",
        "url": 271
    },
    {
        "nl_input": "The query requires a function to directly mint tokens to a Hash Time-Lock Contract (HTLC). The needed code should include a minting function that takes an address (HTLC contract) and a token amount or ID, adds the tokens to the specified address, and emits relevant events (e.g., Transfer or Mint) to ensure proper tracking of the newly minted tokens.",
        "url": 272
    },
    {
        "nl_input": "The query requires a function to change the wallet address, ensuring the new address is valid and not the zero address. The function should be accessible only by the owner and update the wallet address accordingly. Some implementations also include additional checks to prevent setting the contract or token address as the new wallet.",
        "url": 273
    },
    {
        "nl_input": "The query requires a function to retrieve the namespace associated with a given address from a service locator. It needs to accept an address as input and return the corresponding namespace string, handling cases where the record may have expired or does not exist by returning an empty string.",
        "url": 274
    },
    {
        "nl_input": "The query requires a function to create free tokens with a specified name and transfer them to a recipient address, ensuring the recipient is valid and not prohibited. It should also limit the total supply of created tokens and increment a counter after creation. The function must be callable by an authorized admin externally.",
        "url": 275
    },
    {
        "nl_input": "The query requires a modifier function named \"onlyOwner\" that restricts contract functions to be executable only by the contract owner, ensuring security and access control. The suitable code enforces this by checking if the message sender matches the defined owner using a require statement. Any deviation, such as allowing non-owners, does not meet the requirement.",
        "url": 276
    },
    {
        "nl_input": "The query requires ensuring that Ether (ETH) cannot get locked in the contract. The focus is on implementing a mechanism, such as modifiers or conditions, to prevent ETH from being inadvertently locked within the contract, ensuring it remains accessible or withdrawable when needed. This involves avoiding unintended ETH retention and enabling controlled interactions.",
        "url": 277
    },
    {
        "nl_input": "The query requires an efficient method to claim all tokens for a specific investor, utilizing the `msg.sender` parameter. The solution should involve a function that directly calls or implements the logic of `claimAllForInvestor(msg.sender)` to streamline the claiming process for the sender.",
        "url": 278
    },
    {
        "nl_input": "The query requires a function to return the price of a specific team based on the team ID. The relevant code contains a function named `getTeamPrice`, which takes `_teamId` as an argument and returns the current price of the specified team from the `teams` mapping. This matches the requirement to retrieve a specific team's price.",
        "url": 279
    },
    {
        "nl_input": "The query requires a function to modify the timing for the next occurrence of a specific event, namely \"steal time.\" It should accept a parameter to adjust this timing, likely in seconds, and update the timestamp accordingly. The function needs to be internal and part of a smart contract system managing event schedules or timers.",
        "url": 280
    },
    {
        "nl_input": "The query requires a function to return the registration date of a holder associated with a given address. The needed code should take an address as input and output the corresponding registration timestamp, ensuring the data is accurately retrieved from the stored records.",
        "url": 281
    },
    {
        "nl_input": "The query requires a function to update the reward rate for a specific token, ensuring the new rate is positive and the token address is valid. It involves iterating through a list of reward sources, matching the token address, and updating the reward rate accordingly. The implementation must include validation checks and be accessible only to the contract owner.",
        "url": 282
    },
    {
        "nl_input": "The query requires functionality to create or activate an owner within a smart contract system. This involves adding a new owner address, ensuring it is not already active, and updating the owner-related mappings or lists accordingly. The process includes validation checks to confirm the address is valid and not already registered.",
        "url": 283
    },
    {
        "nl_input": "The query requires creating a new round in a lottery system, setting a secret hashed salt and proof of N. It involves a function that takes two parameters, _saltHash and _saltNHash, creates a new lottery round with these secrets, ensures proper funding, transfers ownership to the original owner, and emits an event upon successful creation.",
        "url": 284
    },
    {
        "nl_input": "The query requires a function to set a soft cap value in a smart contract, converting the input to a specific unit (10^12). The relevant code defines a function `setSoftCap` that accepts a uint256 parameter `_softCap`, multiplies it by 10^12, and assigns it to the `softCap` variable. This meets the requirement for adjusting the soft cap with proper unit conversion.",
        "url": 285
    },
    {
        "nl_input": "The query requires a function to withdraw tokens other than DGZ to a beneficiary. It should handle cases where tokens are mistakenly transferred to the contract and allow the owner to manually withdraw them, specifying the token address and amount. The solution must ensure the specified tokens are transferred to the beneficiary while excluding DGZ tokens.",
        "url": 286
    },
    {
        "nl_input": "The query requires a function to set a block as not for sale, specifically by identifying the block using coordinates (x, y), verifying the owner's permission, and updating the block's sale status to inactive. The relevant code cancels the sale of a block by modifying its \"forSale\" status and emitting an event confirming the change.",
        "url": 287
    },
    {
        "nl_input": "The query requires a function to claim tokens owed to the `msg.sender`. It involves identifying a contract function that processes token claims for the sender, potentially involving specific conditions or parameters like challenge IDs or token allocations, and transferring the appropriate token amount to the sender.",
        "url": 288
    },
    {
        "nl_input": "The query requires a function to retrieve all relevant information about a specific GameItem using its unique token ID. This includes details such as the item's ID, name, selling price, owner address, and associated game ID. The function should be publicly accessible and return these details in a structured format for further use.",
        "url": 289
    },
    {
        "nl_input": "The query requires a function that allows users to claim segments every 1000 blocks (UNITS). Users claiming segments instead of clusters receive half the reward. The function calculates the amount of segments claimed by the user based on their contribution and updates balances accordingly, ensuring users can only claim if eligible.",
        "url": 290
    },
    {
        "nl_input": "The query requires a function to facilitate token exchange between addresses. It needs a mechanism to transfer tokens from one address to another, ensuring proper balance management and authorization. The solution should include functionalities like sending tokens, updating balances, and possibly handling allowances for transfers on behalf of other addresses.",
        "url": 291
    },
    {
        "nl_input": "The query requires a function to facilitate the sale of presale tokens, ensuring the sale is within a specified timeframe, verifying token availability, and managing token pricing based on the number of tokens sold. It also involves transferring tokens to buyers, updating token balances, and handling ether payments and refunds.",
        "url": 292
    },
    {
        "nl_input": "The query requires a function to prevent specific addresses from sending or receiving tokens. This involves either setting a lockup period using Unix timestamps or freezing the accounts by marking them as non-transactable. The solution should allow an owner to specify target addresses and apply restrictions, ensuring restricted accounts cannot participate in token transfers.",
        "url": 293
    },
    {
        "nl_input": "The query requires a function to remove an address from a list or pool. It needs to check if the address exists, adjust the list by replacing the target address with the last one, and reduce the list size. The solution should ensure proper removal while maintaining list integrity.",
        "url": 294
    },
    {
        "nl_input": "The query aims to determine the end date of a customer's term deposit by utilizing a function that retrieves the termination block for a given address. It focuses on identifying when the term deposit period concludes, ensuring accurate tracking of deposit durations within the system.",
        "url": 295
    },
    {
        "nl_input": "The query requires implementing a function to add a CZR lock with specific parameters: address, start lock time, amount, and lock duration in months. The function should handle conditions like ensuring the amount is positive, setting the current time if start lock time is zero, and storing the lock details in a mapping while triggering an event to confirm the lock addition.",
        "url": 296
    },
    {
        "nl_input": "The query requires a function to transfer data layer authority to a new owner. The most relevant code demonstrates a function named `transferDataAuthority`, which takes an address parameter (`newOwner`) and transfers the data authority to this new address, ensuring only the current owner can invoke this function.",
        "url": 297
    },
    {
        "nl_input": "The query requires a function to resolve a challenge associated with a specific `_propID`. It involves checking if the challenge is resolved, determining the winning tokens and reward, and transferring the reward to the appropriate party based on the challenge outcome. The function also emits events indicating whether the challenge succeeded or failed.",
        "url": 298
    },
    {
        "nl_input": "The query requires a function to decrease the approved amount of tokens for a spender. It should adjust the existing allowance by reducing it with a specified value, ensuring the new allowance does not go below zero. If the reduction exceeds the current allowance, it should reset the allowance to zero. The function must also emit an Approval event with updated details.",
        "url": 299
    },
    {
        "nl_input": "The query requires a function to whitelist a list of addresses, allowing an owner or authorized entity to add multiple addresses to a whitelist. This involves iterating through an array of addresses and setting their whitelist status to true, ensuring only authorized parties can perform this action.",
        "url": 300
    },
    {
        "nl_input": "The query requires a function or modifier that ensures a specific function can only be called by a designated source, such as \"shiftSale.\" The extracted information should demonstrate restricted access, ensuring the function is not callable by unauthorized entities, aligning with the \"only from shiftsale\" requirement.",
        "url": 301
    },
    {
        "nl_input": "The query requires extending OpenZeppelin's StandardToken transferFrom function to include snapshot functionality. It needs to capture the state of token balances before and after a transfer by calling a snapshot function for both sender and receiver addresses, ensuring accurate tracking of token movements at specific points in time.",
        "url": 302
    },
    {
        "nl_input": "The query requires a function to check the amount of tokens delegated by an owner to a spender. It needs the owner's address, the spender's address, and returns the remaining token amount allowed for the spender. The function is essential for managing token approvals and ensuring accurate delegation tracking in a smart contract.",
        "url": 303
    },
    {
        "nl_input": "The query requires a function to add intervals with specified begin and end points, along with associated data, into a tree structure. The function should handle the creation of intervals and nodes, and use a depth-first search to find the correct position for the new interval based on the center value of current nodes. If the interval encompasses the center, it should be added to the current node.",
        "url": 304
    },
    {
        "nl_input": "The query requires a function to withdraw tokens only after the crowdsale ends and is finalized. It ensures that users can claim their tokens if the crowdsale is successful, by checking if the crowdsale has closed and been finalized before allowing token withdrawal. The function resets the user's balance and delivers the tokens to the sender.",
        "url": 305
    },
    {
        "nl_input": "The query requires a function to return the balance of tokens for a given owner's address. It needs a parameter for the owner's address and should return the corresponding token balance. The function is intended to be publicly accessible and constant/view, ensuring no state changes occur while retrieving the balance.",
        "url": 306
    },
    {
        "nl_input": "The query requires a function to update or set a new token address, ensuring the address is valid and not the same as the current contract or token address. It should also emit an event upon successful update and restrict this functionality to the contract owner.",
        "url": 307
    },
    {
        "nl_input": "The query requires a function to update the status of a board based on the losing color in a game context. Specifically, it needs to set the board status to indicate which color (White or Black) has won, depending on the losing color provided. If the losing color is invalid, the function should handle this case appropriately, potentially by reverting the transaction.",
        "url": 308
    },
    {
        "nl_input": "The query requires a function to determine if an event has ended, returning true when the current time exceeds the end time or when no tokens remain. Alternatively, it could return true based on a finalized state. The function should be publicly accessible and provide a boolean result.",
        "url": 309
    },
    {
        "nl_input": "The query requires a function or modifier to check if a given address is an eligible burner. The solution should include a mechanism, such as a mapping or predefined address, to verify the burner's eligibility using a conditional statement. The provided code snippets demonstrate modifiers that implement similar validation logic.",
        "url": 310
    },
    {
        "nl_input": "The query requires a function to handle multisignature transactions with specific parameters: destination address, value in Wei, data, expire time, sequence ID, and signature for security. It involves verifying signers, ensuring transaction validity through timestamps, and preventing replay attacks by using unique sequence IDs. The function should execute the transaction if properly authorized.",
        "url": 311
    },
    {
        "nl_input": "The query requires a function to handle the removal of rotted potatoes for a user. It needs to calculate the amount of potatoes that have rotted based on time elapsed, update the user's potato count by subtracting the rotted amount, and add the rotted potatoes to the user's trash count. The function should also record the current timestamp after processing.",
        "url": 312
    },
    {
        "nl_input": "The query requires a function to determine the renewal interval of a product in seconds, given the product ID. It needs to retrieve the specific interval value associated with the provided product ID from a data structure storing product information. The result should be returned as a uint256 value.",
        "url": 313
    },
    {
        "nl_input": "The query requires a function allowing users to withdraw owed values recorded under addressToFailedOldOwnerTransferAmount. It should check if the amount is greater than zero, reset the user's failed transfer amount, deduct from total failed amounts, and transfer the owed value to the user's address securely. The solution must prevent re-entry attacks and ensure accurate balance management.",
        "url": 314
    },
    {
        "nl_input": "The query requires a function to calculate winnings based on a given bet amount and percentage. It seeks a straightforward computation where the winnings are determined by multiplying the bet by the percentage and then dividing by 100. The solution should be implemented as a pure function for simplicity and accuracy in calculations.",
        "url": 315
    },
    {
        "nl_input": "The query requires functionality allowing both the Owner and Admin to change the admin address. The provided code snippets demonstrate mechanisms for updating the admin address, with varying conditions and access control (e.g., `onlyOwner`, `onlyOwnerOrAdmin`). The requirement involves implementing a function to securely modify the admin address while ensuring proper authorization and validation.",
        "url": 316
    },
    {
        "nl_input": "The query requires a function to simulate the creation of a leaderboard hash using a name and admin address, as seen in the provided code where a hash is generated with `keccak256` by encoding the name and admin. The other codes check entity presence on leaderboards but are irrelevant to hash creation.",
        "url": 317
    },
    {
        "nl_input": "The query requires setter methods that can only be executed in the unlocked state. Specifically, it needs a function allowing the owner to set certain parameters (e.g., oversight address) while ensuring the contract is not locked. This ensures security by restricting changes unless the contract is in an unlocked condition.",
        "url": 318
    },
    {
        "nl_input": "The query requires a function to add content to an agreement, including parameters such as name, description, and reward. The most relevant code should allow adding content with these details, ensuring proper validation and permission checks, and confirm successful addition through a return value.",
        "url": 319
    },
    {
        "nl_input": "The query requires a function to update the rate for a specific round, allowing the owner to modify the rate associated with a given round number. The function should ensure the round number is within the valid range and then update the corresponding rate in the rounds array.",
        "url": 320
    },
    {
        "nl_input": "The query requires a function to mark products by adding a product account and hashing the item's public key using sha3. The function should ensure active product, brand, and app statuses, check permissions, record markings, emit events, and handle fees using token transfers. It involves interactions between multiple entities and their accounts.",
        "url": 321
    },
    {
        "nl_input": "The query requires a function to end an auction, ensuring it transitions to the \"Ended\" state, and transfers the highest bid to the auction owner. The relevant code should handle state changes, emit an event indicating the auction's conclusion, and facilitate the transfer of funds to the owner upon successful execution.",
        "url": 322
    },
    {
        "nl_input": "The query requires a function to retrieve an owner's address based on a 0-indexed position from a list or array of owners. The function should take an index as input and return the corresponding owner's address, ensuring the index is correctly adjusted if the internal storage uses 1-based indexing.",
        "url": 323
    },
    {
        "nl_input": "The query requires a function to set an initial date and token address for a bonus sale, ensuring the token's total supply is zero and ownership is correct. The function should restrict access to the owner and ensure the process occurs at the setup stage, updating the sale dates and transitioning the current stage to ready.",
        "url": 324
    },
    {
        "nl_input": "The query requires a function to return the ticket price for a bet. Specifically, it needs a public view function that retrieves and returns the value of 'ticketPrice'. This indicates the requirement for a getter function in a smart contract that exposes the ticket price variable to external access without modifying the state.",
        "url": 325
    },
    {
        "nl_input": "The query requires a function that is executed when tokens are purchased during a token sale. It should handle the creation and transfer of tokens to the buyer's address, ensuring valid inputs and updating the total supply and balances accordingly. The function must also emit an event indicating the minting of tokens and their transfer to the beneficiary.",
        "url": 326
    },
    {
        "nl_input": "The query requires a function to enable token transfers, burn unsold tokens, and set the token offering address to zero. It needs a mechanism to activate token transfer, handle unsold tokens by burning them, and reset the offering address after the process, ensuring proper post-offering token management.",
        "url": 327
    },
    {
        "nl_input": "The query requires a function to place a bet using an Access Code and Mode parameter. The function should ensure the bet is not directly invocable, utilize odds based on whether it's the user's first game, and involve hashing for security. It must also handle betting limits, block usage, and random number generation for determining winners.",
        "url": 328
    },
    {
        "nl_input": "The query requires a function to compute the status of a transcoder. Specifically, it needs to determine whether a given transcoder address is registered or not by checking if it exists in a transcoder pool. The result should return a status indicating \"Registered\" or \"NotRegistered\" based on this condition.",
        "url": 329
    },
    {
        "nl_input": "The query requires a function to fill a buy order using a corresponding sell order. It involves calculating tokens obtained, handling fees, and ensuring the exchange process complies with specific conditions. The function should interact with trading mechanisms, validate inputs, and return the updated token and ether balances after execution.",
        "url": 330
    },
    {
        "nl_input": "The query requires a function that enables token transfers once trading has started. It should include parameters for the recipient's address and the number of tokens to be transferred, ensuring the transfer is permissible based on trading status. The solution must integrate checks and permissions to confirm that trading has commenced before allowing the token transfer.",
        "url": 331
    },
    {
        "nl_input": "The query requires a function to return the available token allocation for a given address. It checks if the address is eligible and calculates the available tokens based on predefined time steps (step1, step2, step3) and corresponding allocations. The result is the total available tokens for the specified recipient address.",
        "url": 332
    },
    {
        "nl_input": "The query requires a function that transfers and locks a value, callable only by admins, with a limit when setting the lock. It involves transferring tokens to an address with a specified lock time. The function should ensure restricted access and proper locking mechanism enforcement.",
        "url": 333
    },
    {
        "nl_input": "The query requires a function to transfer ether to the beneficiaryAddress. It needs to specify the amount of ether to be transferred, ensure the contract holds sufficient balance, and confirm the successful execution of the transfer process. The function should ideally include safety checks and return a status indicating success.",
        "url": 334
    },
    {
        "nl_input": "The query requires a function to retrieve the address of the library founder using a token ID. The needed code should have a function named \"founderOf\" that takes a uint256 parameter (_tokenId) and returns the founder's address, ensuring the address is not zero. This involves mapping token IDs to founder addresses and validating the result.",
        "url": 335
    },
    {
        "nl_input": "The query requires a function that allows users to delete their accounts. The selected code provides a deleteUser() function, which removes the user's information from address and user directories, ensuring no data remains associated with the user, and emits a UserDeleted event to confirm the deletion. This meets the requirement for account deletion functionality.",
        "url": 336
    },
    {
        "nl_input": "The query requires a function that allows buyers to claim tokens they've purchased. The function should handle token allocation, ensure the correct stage of the sale, and transfer tokens to the buyer's address while resetting their allocation records. This ensures users can retrieve their purchased tokens after the sale concludes.",
        "url": 337
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the caller to a new holder, with a 10% fee included in the process. The function should ensure the caller holds sufficient tokens for the transfer and utilize an internal transfer mechanism to complete the transaction.",
        "url": 338
    },
    {
        "nl_input": "The query requires a function to ensure the sale is properly configured and has not yet finished. It should check if the sale configuration is valid, confirm the sale hasn't ended, and potentially verify that it has started. The solution must prevent actions on an unconfigured or finalized sale.",
        "url": 339
    },
    {
        "nl_input": "The query requires calculating the total Ether needed to purchase an item, considering fees and balance checks. It involves functions that process purchases, calculate token amounts based on Ether input, and ensure sufficient balance for fee deduction. The relevant code handles Ether transactions, fee collection, and token issuance, ensuring successful purchase completion.",
        "url": 340
    },
    {
        "nl_input": "The query requires a function to calculate and return the bonus percentage based on the current ICO stage. It should consider different bonus percentages for specific time periods during the ICO, reducing over time. The solution must evaluate the current timestamp against predefined stages to determine the applicable bonus, ensuring it returns zero if the timestamp exceeds the final stage.",
        "url": 341
    },
    {
        "nl_input": "The query requires a function to finish the crowdsale and permanently stop minting tokens. The desired functionality involves setting a flag to indicate that minting is finished, recording the date when minting stops, and ensuring no further tokens can be minted after finalizing the crowdsale process.",
        "url": 342
    },
    {
        "nl_input": "The query requires a function to participate in an airdrop, ensuring the participant meets specific conditions such as limited participants, time constraints, and no prior participation. It involves issuing tokens to the participant's address and updating participation status and counts.",
        "url": 343
    },
    {
        "nl_input": "The query requires a function to retrieve ELHT token information based on a given Token ID, with a maximum of 64 tokens. It needs logic to handle token retrieval, possibly involving token balance checks or transfers, ensuring the correct token information is returned according to the specified Token ID. The provided code references token handling but does not directly match the query's specific requirement.",
        "url": 344
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to authorize redemptions in units of 1/1000 ETH. The solution should involve a contract function that authorizes addresses with specific amounts of micro-ETH (mEth) and ensures the contract balance is sufficient. It must handle redemption logic, including transferring authorized amounts and managing redemption states.",
        "url": 345
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer ether, either to another address or an updated contract. The function should ensure the specified amount does not exceed the contract's balance and should only be callable by the owner. It involves transferring ownership or withdrawing ether while maintaining security and proper authorization.",
        "url": 346
    },
    {
        "nl_input": "The query requires identifying the address of an Oracle contract that implements the OracleInterface. The code provides a function to propose an oracle with details stored via IPFS hash, ensuring balance checks and emitting events upon proposal. The requirement focuses on the interaction and proposal mechanism for oracles, involving addresses and specific contract interactions.",
        "url": 347
    },
    {
        "nl_input": "The query requires a function to create a trade offer using msg.value with a specified setting. The function should ensure that both msg.value and the setting are greater than zero before proceeding with the internal offer creation process. This ensures valid inputs for the trade offer functionality.",
        "url": 348
    },
    {
        "nl_input": "The query requires a function to check the token balance of a specific address holder. It needs a method like `balanceOf` that takes an address as input and returns the corresponding token balance. The function should be accessible publicly or externally and must correctly reference the balance mapping for the given address.",
        "url": 349
    },
    {
        "nl_input": "The query requires a function to check the results of a fundraiser in USD. Specifically, it needs to calculate the total funds raised, convert them from the contract's native currency (likely ETH) to USD using a predefined rate, and return the converted amount as a rated value in USD. The function should be internal and return a uint256 value representing the total funds in USD.",
        "url": 350
    },
    {
        "nl_input": "The query requires a function to track and calculate the available token balances for rewards distributed from a token pool. It should consider beneficiary allocations, percentage distributions, and ensure accurate balance updates when tokens are claimed or transferred. The solution must involve iterating through token allocations and applying percentage calculations to determine the correct token amounts.",
        "url": 351
    },
    {
        "nl_input": "The query requires a function to collect service/affiliate fees for a purchase. It needs to calculate the fee based on the transaction amount, ensure sufficient balance, deduct the fee, and transfer it to the affiliate. The function should return the remaining amount after fee deduction.",
        "url": 352
    },
    {
        "nl_input": "The query requires an internal function to verify if transferring a specific token is permitted, taking parameters for the sender (_from), receiver (_to), and token ID (_tokenId). It should return a boolean value indicating whether the transfer is allowed based on certain conditions or external logic.",
        "url": 353
    },
    {
        "nl_input": "The query requires overriding the MintableToken's transferFrom function to incorporate KYC (Know Your Customer) logic. This ensures that token transfers comply with regulatory requirements by checking KYC status before allowing transactions, thus adding an additional layer of verification and control to the standard transferFrom functionality.",
        "url": 354
    },
    {
        "nl_input": "The query requires a function to change the address associated with a specific role. The function should ensure that only authorized entities can perform this change, possibly involving checks for sender authorization and updating related mappings or arrays to reflect the new address while maintaining role-specific permissions.",
        "url": 355
    },
    {
        "nl_input": "The query requires a function to withdraw ZRX tokens when a new contract version is deployed. It needs a function that allows an admin to specify the amount of ZRX tokens to be transferred from the contract to an admin address, ensuring flexibility and control over the token withdrawal process in case of updates or changes.",
        "url": 356
    },
    {
        "nl_input": "The query requires a modifier to ensure that transfers are only allowed after the minting process has completed. This involves checking if minting is finished before enabling transfer functionality, using a boolean flag or similar mechanism to confirm that minting has concluded. The provided code demonstrates an example of such a modifier implementation.",
        "url": 357
    },
    {
        "nl_input": "The query requires a function to refund funds when the softcap is not reached and the sale period has ended. It should check if a user is eligible for a refund, deduct the refunded amount from the user's balance, and transfer the funds back to the user while emitting an event to record the refund details.",
        "url": 358
    },
    {
        "nl_input": "The query requires a function to determine if the contribution period is currently active. It needs to check conditions such as whether the hard cap is reached, if the contribution is enabled, and if the current time is within the start and end times of the contribution period. The function should return a boolean value indicating if the period is running.",
        "url": 359
    },
    {
        "nl_input": "The query requires an internal function to manage ICO status when tokens are sold out. It involves transitioning statuses based on token availability across different ICO stages (PrivateICO, Pre-ICO, ICO). The function updates the status to 'Waiting' if tokens for a stage are sold out and sets it to 'Closed' when all ICO tokens are exhausted.",
        "url": 360
    },
    {
        "nl_input": "The query requires a function that allows the owner to add addresses which have the permission to burn tokens, such as ICO or TGE contracts. The function should take an address as a parameter and add it to a list of whitelisted burn addresses.",
        "url": 361
    },
    {
        "nl_input": "The query requires a function that allows a wallet to claim ownership of an account by providing an app nickname, post ID, gas price, and gas limit. It involves verifying the signature through an external API and ensuring sufficient funds for the Oraclize transaction. The function logs the verification process and associates it with the sender's address.",
        "url": 362
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of a collectible item, involving fee collection and ensuring proper balance handling. It needs to account for fees, check balances, and manage transactions securely, potentially including affiliate payments and token transfers. The solution should handle payable interactions and address restrictions effectively.",
        "url": 363
    },
    {
        "nl_input": "The query requires a function to determine the next minimal bid or final bid in auctions. It should handle cases where an auction has ended and return the highest bid or calculate the next bid by adding a minimal raise value to the current bid, ensuring accurate bid management in auction contracts.",
        "url": 364
    },
    {
        "nl_input": "The query requires a function to create promo narco items, allowing customization of attributes such as genes, name, and owner address, while ensuring creation is limited by a predefined promo limit. The function should handle default owner assignment if the provided address is invalid.",
        "url": 365
    },
    {
        "nl_input": "The query requires a function to modify basic ICO parameters, such as start/end dates, funding caps, and transaction limits. It should allow changes only during a suspended state and apply provided values if they are non-zero, ensuring constraints like lowCapWei \u2264 hardCapWei and lowCapTxWei \u2264 hardCapTxWei are maintained. This ensures flexibility while preserving ICO integrity.",
        "url": 366
    },
    {
        "nl_input": "The query requires a function that allows only a specific address (override address) to change itself. The function should take a new address as input, update the override address, and return a confirmation. It must include security measures to ensure only the authorized address can perform this action.",
        "url": 367
    },
    {
        "nl_input": "The query requires a function to approve multiple token IDs at once. It needs a method that accepts an address and an array of token IDs, verifies ownership for each token, sets the approval for each token ID to the specified address, and emits an Approval event for each approved token. This allows batch approval of tokens in a single operation.",
        "url": 368
    },
    {
        "nl_input": "The query requires a function to buy DOL tokens from VAULT by sending ETH. The code should facilitate the transfer of ETH to a contract or vault address in exchange for DOL tokens, ensuring proper balance adjustments and token transfers while adhering to conditions such as time constraints or player states.",
        "url": 369
    },
    {
        "nl_input": "The query requires a function to handle the process after a crowdsale ends, specifically sending remaining tokens back to the wallet. It needs a mechanism to ensure the crowdsale has concluded and possibly check goal attainment before executing token transfer or refund procedures. The focus is on finalization processes within smart contracts.",
        "url": 370
    },
    {
        "nl_input": "The query requires initiating a poll with specific parameters, including vote quorum, commit duration, and reveal duration, as emitted by the PollCreated event. The solution involves creating a poll with defined majority types and time periods, ensuring proper configuration and emission of the corresponding event for successful poll initiation.",
        "url": 371
    },
    {
        "nl_input": "The query requires a function to set an individual cap for Stage 2 of a crowdsale. Specifically, it needs a method that allows setting the maximum allocation per investor for Stage 2, ensuring control over investment limits. The relevant code should be callable by authorized users and accept a uint256 value as the cap.",
        "url": 372
    },
    {
        "nl_input": "The query requires a function to calculate and withdraw unsold tokens back to the seller, ensuring buyer withdrawals remain unaffected. It needs logic to determine the balance of tokens available for withdrawal, subtracting any commitments to buyers, and transferring the remaining tokens to the seller's address.",
        "url": 373
    },
    {
        "nl_input": "The query requires extracting pricefeed specific information, such as blockNumber, nonce, ask, and bid values, along with verifying signatures and encoding new price feeds. It involves ensuring the integrity and validity of price data through comparisons and cryptographic verification before updating the price feed. The focus is on managing and retrieving price-related data accurately.",
        "url": 374
    },
    {
        "nl_input": "The query requires a function to set a security check report URI. The function should allow setting an URI for security reports, likely accessible only to the owner for maintaining control over the security information. This ensures that the URI can be updated as needed for reporting purposes while restricting access to authorized entities.",
        "url": 375
    },
    {
        "nl_input": "The query requires a function that calculates the number of tokens purchasable with a specified amount of wei. It needs to take an input value (weiAmount) and return the corresponding token amount, potentially considering factors like exchange rates or tiers for different wei amounts. The focus is on determining token quantities based on provided wei inputs.",
        "url": 376
    },
    {
        "nl_input": "The query requires a function to set the sale status of an account, enabling it to transfer tokens during the frozen state. It should only be usable during the token sale phase and before the privileged functions are disabled, involving parameters like account address and boolean for sale status.",
        "url": 377
    },
    {
        "nl_input": "The query requires a method to calculate the developer's cut in a game, specifically using a formula that multiplies a given price by a developer cut percentage (in promille) and divides it by 1000. The implementation should be private, accept a uint256 price as input, and return the calculated cut as a uint value.",
        "url": 378
    },
    {
        "nl_input": "The query requires extending the functionality of OpenZeppelin's StandardToken by adding a snapshot mechanism to the transferFrom method. This involves taking snapshots of the sender and receiver addresses before executing the token transfer, ensuring additional data capture during transactions while maintaining original transfer functionality.",
        "url": 379
    },
    {
        "nl_input": "The query requires a code modifier that restricts function access to authorized accounts only, throwing an error if called by any other account. This ensures that only specific, authorized entities can execute certain functions, maintaining security and control within the contract. The provided code examples demonstrate different implementations of such authorization checks.",
        "url": 380
    },
    {
        "nl_input": "The query requires a function to set the deposit gas cost with a parameter for the new gas cost value. It should be accessible only to authorized entities, ensuring security and proper management of gas costs within a smart contract environment. The function updates the deposit gas cost accordingly.",
        "url": 381
    },
    {
        "nl_input": "The query requires a function to send `_value` tokens to `_to` from `msg.sender`. It needs a method that transfers tokens on behalf of the sender, ensuring proper authorization and balance checks. The function should involve parameters `_to` (recipient address) and `_value` (amount to transfer), with logic to deduct tokens from the sender's balance and add them to the recipient's balance.",
        "url": 382
    },
    {
        "nl_input": "The query requires implementing a function to transfer any accidentally sent ERC20 tokens to the owner's address. It should include a function that specifies the token address and amount, with only the owner authorized to execute it. Additionally, it may involve checking the balance of ERC20 tokens held by the contract for proper functionality.",
        "url": 383
    },
    {
        "nl_input": "The query requires a function to disable token transfers, ensuring that no tokens can be moved between addresses until re-enabled. The desired functionality should restrict transfer operations, likely through a pause mechanism or similar approach, and must be executable by an authorized entity, such as a manager or owner.",
        "url": 384
    },
    {
        "nl_input": "The query requires a mechanism to restrict token transfers based on the tradingOpen modifier, ensuring transactions are allowed only if the sale is open or after December 24, 2017. The relevant code should include a function using the tradingOpen modifier to control transfer functionality, aligning with the specified conditions for enabling or disabling transfers.",
        "url": 385
    },
    {
        "nl_input": "The query requires a modifier that allows actions only when the funds are not locked. This means the code should include a condition that ensures certain functions can only be executed if the funds' locked status is false, opposite to the provided 'whenLocked' modifier. The requirement focuses on implementing a 'whenNotLocked' type functionality.",
        "url": 386
    },
    {
        "nl_input": "The query requires an internal function for handling ETH refunds during stage three, ensuring the sender is authorized (owner or receiver), the contribution meets the minimum value, and logs the refund amount with an event notification. It focuses on a specific refund mechanism within a contract's defined stage.",
        "url": 387
    },
    {
        "nl_input": "The query requires implementing a function to send bonus rewards to a contract, potentially involving conditions such as ownership verification, bonus limits, or updating bonus pools. It should handle value transfers and possibly record bonus distributions or member states within the contract.",
        "url": 388
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on the input value (e.g., wei or eth) using predefined rates. The function should consider different tiers or bonuses and return the corresponding token amount. It may involve multiplying the input value by a rate and handling edge cases like zero input.",
        "url": 389
    },
    {
        "nl_input": "The query requires a function to withdraw ETH from a contract, typically restricted to the owner. It involves transferring a specified amount (in wei) to one or more addresses or sending the entire contract balance to the owner. The implementation may include checks to ensure sufficient balance before executing the transfer.",
        "url": 390
    },
    {
        "nl_input": "The query requires a function to update a specific parameter within a smart contract, ensuring the caller has appropriate permissions. The function should validate input and emit an event upon successful execution. This involves modifying contract states like minimum contribution, inflation rate, or upgrading contract ownership, with conditions to prevent unauthorized access and ensure logical consistency.",
        "url": 391
    },
    {
        "nl_input": "The query requires overriding the token purchase function to send additional tokens to registered addresses. It needs a function that processes purchases, adds purchased tokens to the beneficiary's balance, and ensures compatibility with registered addresses. The solution should handle token amounts, beneficiary deposits, and maintain accurate accounting for token distribution.",
        "url": 392
    },
    {
        "nl_input": "The query requires a function to return the total number of tokens in existence as a uint256 value. It needs to be publicly accessible and view-only, ensuring no state modifications. The function should accurately reflect the current total supply of tokens within the contract.",
        "url": 393
    },
    {
        "nl_input": "The query requires a function to set or check the status of a developer. It needs to accept an address and a boolean status, updating the developer's status accordingly and potentially emitting an event to notify of the change. The function should restrict access to authorized users, likely the contract owner.",
        "url": 394
    },
    {
        "nl_input": "The query requires a function allowing users to set rabbit data using a signed message from the COO. The function should verify the signature, ensure data hasn't been used, and update rabbit attributes (explosive, endurance, nimble) for a specific token ID while emitting an event upon completion. Security and authorization through COO signature verification are essential.",
        "url": 395
    },
    {
        "nl_input": "The query requires a function to deposit tokens in a game for a specific user. It involves transferring tokens, ensuring sufficient balance, and updating user balances or wallet balances accordingly. The function should emit an event confirming the deposit and handle cases where the user may or may not already exist in the system.",
        "url": 396
    },
    {
        "nl_input": "The query requires a function to set pre-ICO addresses with a specified token price, allowing disabling by setting the price to 0. It involves managing pre-ICO addresses and their associated token prices, ensuring flexibility to enable or disable specific addresses as needed within a smart contract environment.",
        "url": 397
    },
    {
        "nl_input": "The query requires a mechanism to update prices if the last update occurred more than one day ago. It involves recalculating and saving the current price, potentially adjusting sell prices, and logging the event. This ensures periodic updates to maintain accurate pricing based on predefined growth rates or conditions.",
        "url": 398
    },
    {
        "nl_input": "The query requires a function to freeze multiple accounts simultaneously. The solution should allow an owner to set a freeze status for a list of addresses, updating their frozen state and emitting an event for each address. This involves iterating through the provided addresses and applying the specified freeze status to each account in the system.",
        "url": 399
    },
    {
        "nl_input": "The query requires a function to update the payout for burritos owned by a specific owner. It calculates the owed amount based on burrito data, updates the withdrawn amount for each burrito, and adds the total owed to the owner's payout balance. The function iterates through the owner's burritos and performs calculations based on payout rates and existing balances.",
        "url": 400
    },
    {
        "nl_input": "The query requires an admin function to withdraw PLAT balance. It needs a function that checks the PLAT balance within the contract, allows only authorized users (like admins or owners) to initiate the transfer, and transfers the entire PLAT balance to the caller's address. The function should ensure proper access control and successfully handle the token transfer.",
        "url": 401
    },
    {
        "nl_input": "The query requires a function to verify if all contributors' tokens have been successfully distributed. It involves checking each contributor's status in a list, ensuring their tokens are marked as distributed. The function should iterate through the contributors, validate distribution status, and confirm overall success.",
        "url": 402
    },
    {
        "nl_input": "The query seeks a method to retrieve or process all contributors in a system. Specifically, it requires functionality to either return a list of all contributors, compensate contributors based on their contributions, or verify if tokens have been distributed to all contributors. The desired function should handle contributor data efficiently, potentially using loops or linked lists for traversal.",
        "url": 403
    },
    {
        "nl_input": "The query requires a function to retrieve the amount of tokens currently approved for transfer from the owner's account to the spender's account. It should take two addresses as parameters (_owner and _spender) and return the remaining allowance of tokens that the spender is authorized to withdraw from the owner's account.",
        "url": 404
    },
    {
        "nl_input": "The query requires a function to calculate the amount of tokens returnable for a user. It needs to consider factors such as beneficiary details, token allocation percentages, and possibly the balance or contributions of the user. The function should iterate through allocations and apply percentages to determine the total token amount available for the user.",
        "url": 405
    },
    {
        "nl_input": "The query requires a function to initiate an auction, ensuring the auction's status transitions to active and emits the starting block number. It involves validating the auction's conditions, such as ownership or state, before activation. The provided code examples demonstrate creating auctions with specific parameters like duration, start price, and end price.",
        "url": 406
    },
    {
        "nl_input": "The query requires a function to reenable transfers after a freeze, with an explanation or solution provided as a parameter. The function should be accessible only to authorized users and return a boolean indicating success. It involves updating freeze status and emitting an event with details about the unfreeze action.",
        "url": 407
    },
    {
        "nl_input": "The query requires implementing a function to finalize a token generation event, ensuring the crowdsale has ended, minting remaining tokens, marking the event as finalized, and possibly transferring funds or unsold tokens. It involves ownership validation and triggering specific actions post-crowdsale.",
        "url": 408
    },
    {
        "nl_input": "The query requires a function to calculate points for the round of sixteen, quarter-finals, and semifinals based on match size, round type, and predictions. It involves iterating through predictions, checking team performance against the specified round, and accumulating points accordingly. The result is the total points for the given round and predictions.",
        "url": 409
    },
    {
        "nl_input": "The query requires a function to transfer all Ether held by the contract to an address specified by the owner. The function should ensure only the owner can initiate the transfer and use the contract's balance for the transaction. It must not involve transferring partial amounts or changing contract ownership.",
        "url": 410
    },
    {
        "nl_input": "The query requires a function to set default vesting schedule parameters, including bonus percentage, principle lock percentage, bonus lock period, principle lock period, and early participant Wei price. The function should allow these parameters to be configured and stored for use in a vesting schedule system.",
        "url": 411
    },
    {
        "nl_input": "The query requires a function to handle ETH deposits when all ETH has been withdrawn, ensuring the contract can cover transaction transfer costs. The solution should involve a payable deposit function that activates only when the contract's conditions for successful completion are met, allowing it to receive ETH for covering future transaction expenses.",
        "url": 412
    },
    {
        "nl_input": "The query requires a function to burn all the owner's tokens. The desired function should be callable by the owner, reduce the token balance of the owner, and decrease the total supply accordingly. It must ensure that the burned amount does not exceed the owner's balance and emits an event confirming the burn action.",
        "url": 413
    },
    {
        "nl_input": "The query requires a utility function that ensures a contract function can only be executed once. This involves implementing a modifier, such as `onlyOnce`, which restricts function calls based on a condition (e.g., `functAttempts <= 0`). The focus is on enforcing single execution for specific functions within a smart contract.",
        "url": 414
    },
    {
        "nl_input": "The query requires a function that checks if the amount of fuel to be bought exceeds the available supply for the day. It should return false if buying the amount would result in selling more fuel than the daily supply allows, considering both unreserved and reserved quantities. The function needs to ensure accurate supply management and prevent over-selling.",
        "url": 415
    },
    {
        "nl_input": "The query requires a function to retrieve the total number of tweets for a specific round. It needs a contract with a function that accepts a round number as input and returns the corresponding tweet count, similar to the structure in the first code snippet where `getTweets(uint256 round)` returns `pastRoundsTweets[round]`.",
        "url": 416
    },
    {
        "nl_input": "The query requires implementing a function to set spending allowances for other addresses in a token contract. It should allow a specified address (\"spender\") to spend up to a defined amount (\"value\") on behalf of the token owner. The function needs parameters for the spender's address and the allowance value, returning a boolean to indicate success.",
        "url": 417
    },
    {
        "nl_input": "The query seeks the total supply of xlmgold tokens. The provided code snippets define functions named `totalSupply` within smart contracts, which return the total number of tokens in existence. These functions use variables like `totalSupply`, `numTokens`, or `totalSupply_` to store and return the token supply value. The query requires identifying and extracting this total supply value from the relevant contract function.",
        "url": 418
    },
    {
        "nl_input": "The query requires a time utility function. It needs a function to handle or retrieve time-related data, such as current time, time periods, or time calculations. The provided code examples involve returning the current time in milliseconds, setting time periods, and showing timelock periods, which align with the requirement for time utility functionalities.",
        "url": 419
    },
    {
        "nl_input": "The query requires a function to withdraw DGZ tokens to a beneficiary, specifically used for processing BTC payments. It should increment tokensSoldOnPublicRound and cause a higher burn rate when called. The function must be restricted to the owner and require the crowdsale to be open.",
        "url": 420
    },
    {
        "nl_input": "The query requires a function to safely add two unsigned integers (x and y), ensuring no overflow occurs. If an overflow is detected, an exception should be thrown. The function should return the sum of x and y if the addition is successful. This ensures arithmetic operations remain within the allowable range for uint types.",
        "url": 421
    },
    {
        "nl_input": "The query requires a function to allocate tokens for a private sale. Specifically, it needs to process the purchase by calculating the token amount based on the wei sent, ensuring the private sale stage, and transferring tokens to the beneficiary. If the token pool is insufficient, it adjusts the allocation, updates the sale stage, and refunds excess wei.",
        "url": 422
    },
    {
        "nl_input": "The query requires a function to preallocate a liquid portion of tokens. Specifically, it needs a mechanism to mint tokens for a specified address, reducing the available liquid token supply by the allocated amount and ensuring proper event logging. The solution should involve functions that handle token allocation while maintaining system constraints.",
        "url": 423
    },
    {
        "nl_input": "The query requires a function that returns the total number of Zodiacs currently in existence. It needs a contract with a function similar to \"totalSupply\" or any other that calculates the count of existing Zodiacs by returning the length of a list or array holding Zodiac data, adjusted for any non-Zodiac initial entries.",
        "url": 424
    },
    {
        "nl_input": "The query requires a contract constructor implementation. Among the provided code snippets, none directly represent a standard contract constructor. However, the requirement implies describing a constructor's purpose: to initialize contract state variables and establish foundational settings when a contract is deployed, ensuring proper configuration and access control for subsequent operations.",
        "url": 425
    },
    {
        "nl_input": "The query requires a function to either retrieve the genetic information of a specific hero or claim a hero if the user doesn't own any. It involves operations related to hero ownership, transportation, challenges, and training within a smart contract system. The function should handle cases where the user has no heroes by automatically claiming one for them.",
        "url": 426
    },
    {
        "nl_input": "The query requires setting a transform agent that manages specific transformations. The agent must be non-zero, match the current transform state, and its original supply and funds should align with the total supply and funds. Additionally, the agent must confirm its identity as a valid transform agent before being set.",
        "url": 427
    },
    {
        "nl_input": "The query requires a function to withdraw all ether from a contract. The needed code should transfer the entire balance of the contract to the owner or specified addresses, ensuring no ether remains in the contract after execution. It may include conditions to verify the balance before withdrawal.",
        "url": 428
    },
    {
        "nl_input": "The query requires a function to mint Kin tokens, specifying the recipient address and token ID or amount. It involves ensuring the address is valid, updating token ownership, and emitting a transfer event. The description focuses on minting logic, including internal mint functions and pre-crowdsale minting with supply limits and event logging.",
        "url": 429
    },
    {
        "nl_input": "The query requires a function to execute periodic subscription payments. It needs to handle charging a subscription, updating the payment duration, and ensuring the transaction is authorized by the appropriate parties. The function should also manage state changes and confirm successful execution before returning a status.",
        "url": 430
    },
    {
        "nl_input": "The query requires a function callable by users and token holders to check a specific condition (e.g., \"if Trump is still president\"). It needs a mechanism to verify caller authorization and validate a particular state or external condition. The solution should involve a public function with appropriate access control and logic to evaluate the desired condition dynamically.",
        "url": 431
    },
    {
        "nl_input": "The query requires a mechanism to restrict function calls to the burnable account only. It needs a modifier or function that ensures only the designated burn address can execute specific operations, throwing an exception if any other account attempts to call it. This enforces security and access control for burning tokens or managing burn-related functionality.",
        "url": 432
    },
    {
        "nl_input": "The query requires a function to check if an early purchase has been amended, using the provided index parameter. It involves iterating through a list of amended purchase indexes and confirming if the given index exists within that list, ultimately returning a boolean value indicating whether the early purchase is amended.",
        "url": 433
    },
    {
        "nl_input": "The query requires a function to mark a document as visible using its ID. Specifically, it needs a function that takes a document ID as a parameter and updates its visibility status. The function should ensure only authorized users can perform this action and handle cases where the document is already visible.",
        "url": 434
    },
    {
        "nl_input": "The query requires a function that determines the current round in a system, likely for a blockchain contract. It should return details about the current round by checking specific conditions, such as token amounts or round indices. The function may involve iterating through rounds or using predefined logic to identify the applicable round.",
        "url": 435
    },
    {
        "nl_input": "The query requires a function to update a listingHash's status from 'application' to 'listing' or resolve an existing challenge. It involves checking conditions to either whitelist the application or resolve the challenge, ensuring the correct status transition based on predefined criteria. The function must handle reversion if neither condition is met.",
        "url": 436
    },
    {
        "nl_input": "The query requires a function to handle refund processes based on specific conditions, such as dates or user balances. It involves checking eligibility for refunds, transferring funds back to users, and ensuring the process is secure and accurate. The solution should include logic for verifying refund availability, updating user balances, and executing transactions.",
        "url": 437
    },
    {
        "nl_input": "The query requires a minting function for creating new tokens. Specifically, it needs a function that mints tokens by assigning them to an address, ensuring the address is valid, and adding the token to the owner's list. The function should also emit an event indicating the transfer of the newly minted token.",
        "url": 438
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another while checking if the tokens are dividends to be paid. The function should take the sender's address, receiver's address, and the amount of tokens as parameters, ensuring proper dividend handling before executing the transfer.",
        "url": 439
    },
    {
        "nl_input": "The query requires a function to refund investments to investors when specific conditions are met, such as softcap not being reached or the sale period ending. It involves resetting investment records and transferring funds back to investors' addresses. The solution should handle multiple investors, ensure proper balance checks, and update related data like total raised funds and distributed tokens.",
        "url": 440
    },
    {
        "nl_input": "The query requires a function to set the KYC contribution cap for a single address based on a specified level. The contribution cap varies depending on the level: 50,000 ether for levels >=3, calculated values for levels 1 and 2 based on SafeMath operations, and 0 for other cases. The function should return true upon successful execution.",
        "url": 441
    },
    {
        "nl_input": "The query requires a function to return the current exchange rate of LNC per Ether. It needs to check if an investor is an initial investor and return a specific exchange rate (EarlyInvestorExchangeRate) or the standard exchange rate (exchangeRate). The solution should involve a constant function that takes an investor's address as input and returns the corresponding exchange rate.",
        "url": 442
    },
    {
        "nl_input": "The query requires a function to update the minimum contribution needed for participation, callable by authorized users (e.g., management or owner). The function should accept a new value greater than zero and update the minimum contribution accordingly, potentially emitting an event to log the change.",
        "url": 443
    },
    {
        "nl_input": "The query requires a function to manually send tokens to a specified address, ensuring the address is whitelisted and the token amount is valid. It checks if the operation occurs during Pre-ICO or ICO phases, transfers tokens accordingly, and records purchase information. If conditions aren't met, the transaction reverts. Only privileged addresses can execute this function.",
        "url": 444
    },
    {
        "nl_input": "The query aims to determine the number of voters who have voted for a specific proposal, identified by its root hash. It requires a function that takes the proposal's root hash as input and returns the total number of voters associated with that proposal. The relevant code provides such functionality by accessing the proposal's voter count stored in a mapping.",
        "url": 445
    },
    {
        "nl_input": "The query requires a function to add a user's address to a list of participants, ensuring no duplicates. It checks if the user address already exists in the participants' list and adds it if not present, maintaining the integrity of the participant list within a specific lottery or event context.",
        "url": 446
    },
    {
        "nl_input": "The query requires a function to deauthorize an issuer, specifically by removing or revoking their authorization status. The function should be callable only by an authorized entity (e.g., owner) and should emit an event indicating the removal of the issuer. This ensures proper tracking and management of authorized issuers in a smart contract system.",
        "url": 447
    },
    {
        "nl_input": "The query requires a function to calculate the amount of non-vested tokens at a specific time for a given token grant. It needs to take the grant details and a timestamp as inputs and return the number of tokens that have not yet vested by that time.",
        "url": 448
    },
    {
        "nl_input": "The query requires setting up an array with vesting stages, including dates and percentages. Specifically, it involves defining multiple stages where each stage has a timestamp relative to a starting point and a corresponding percentage of tokens unlocked at that stage. This setup allows for gradual token release over defined periods.",
        "url": 449
    },
    {
        "nl_input": "The query requires a function to handle token purchases by sending ether, ensuring the value meets a minimum threshold, calculating tokens based on the ether sent, updating balances or issuing tokens, and transferring ether to a designated wallet. It should also include events or notifications for transparency.",
        "url": 450
    },
    {
        "nl_input": "The query requires a function to return the number of contributors for all campaigns. It needs to identify contributors and count them, likely returning an array or count of contributor IDs or addresses associated with campaign contributions. The solution should handle cases where there are no contributors by returning an empty array or zero.",
        "url": 451
    },
    {
        "nl_input": "The query requires a function to handle token sales during crowd time. It involves transferring tokens from the contract to an investor's address, updating available supply, and ensuring proper accounting of sold tokens. The function should be internal, restricting access to authorized parts of the contract, and manage token balances accurately during the sale process.",
        "url": 452
    },
    {
        "nl_input": "The query requires a function or modifier to validate if an address is a suitable destination for token transfers. It must ensure the address is neither the zero address nor the token contract's own address. Additional exclusions, such as specific addresses like owner or admin, may also be considered for enhanced validation.",
        "url": 453
    },
    {
        "nl_input": "The query requires a function to add an address as an administrator for the token, even when the contract is paused. The function should check if the address is already an administrator and return true if the address is successfully added, or false if it was already an administrator. This ensures only unique administrators are added.",
        "url": 454
    },
    {
        "nl_input": "The query requires a function to extract an address or bytes32 type directly from transaction data without manual casting. The solution should accept bytes input and return the decoded address or bytes32 value efficiently. This involves parsing the byte array, ensuring proper length, and utilizing assembly for optimized address retrieval or iterating through bytes to construct a bytes32 output.",
        "url": 455
    },
    {
        "nl_input": "The query requires a function to add a fee privately for a specific address, updating the fee amount if the address already exists. The function should take an address and a fee value as parameters, checking if the fee for the address is zero before setting or adding the new fee. This ensures private modification of fees for individual addresses.",
        "url": 456
    },
    {
        "nl_input": "The query requires implementing re-entry protection in a smart contract to prevent recursive calls that could lead to security vulnerabilities. The solution involves using a modifier, such as `isRunning`, which ensures a function does not re-enter by setting a boolean flag (`running`) to true during execution and resetting it afterward.",
        "url": 457
    },
    {
        "nl_input": "The query requires a function to filter buyers based on their approval status as investors. It needs to iterate through a list of buyers, select those matching the specified investor status, and return a filtered list of addresses. The function should handle memory allocation and ensure no empty addresses are included in the final result.",
        "url": 458
    },
    {
        "nl_input": "The query requires a function modifier that restricts function execution to the contract owner only, ensuring proper ownership validation. The modifier should confirm that the message sender (msg.sender) matches the predefined owner address, allowing execution only if the condition is met. This enforces secure access control in smart contracts.",
        "url": 459
    },
    {
        "nl_input": "The query requires a function to set the \"paused\" variable to false, typically used in smart contracts to resume normal operations. It should be callable by the owner only and may include an event emission to notify about the unpause action. The function name is likely \"unpause\" and involves modifying the state of the \"paused\" boolean variable.",
        "url": 460
    },
    {
        "nl_input": "The query requires a function to release tokens, allowing transfers after ensuring they are initially locked. The function should be callable only by the owner and confirm that the tokens are not already released, then sets the release state to true, enabling token transfers upon execution.",
        "url": 461
    },
    {
        "nl_input": "The query requires a function to check the amount of ACE Equity Tokens a spender is allowed to spend from an owner's account. It needs the owner's address, the spender's address, and should return the remaining allowance of tokens that the spender can use. This involves accessing a mapping that stores allowances between owner-spender pairs.",
        "url": 462
    },
    {
        "nl_input": "The query requires a mechanism to handle unsold tokens after a crowdsale, ensuring they are returned to the wallet or coin itself. It also involves distributing bonus tokens and managing refunds if the minimum cap is not reached, including burning tokens and transferring funds back to backers. The focus is on finalization, token distribution, and refund processes.",
        "url": 463
    },
    {
        "nl_input": "The query requires a function to retrieve the balance of a specific account. It needs an address as input and returns the balance associated with that account. The function should be publicly accessible, view-only, and return the token count or balance for the given address. This allows users to check account balances without altering the state.",
        "url": 464
    },
    {
        "nl_input": "The query requires a function to claim ownership of a specific unicorn ID. It needs to verify the caller's eligibility and transfer ownership from the current owner to the sender, ensuring proper allowance and utilizing the unicorn ID as a parameter within the function.",
        "url": 465
    },
    {
        "nl_input": "The query requires a function that handles asset redemption during both paused and non-paused states. It needs to update the total assets on deposit by adding new units, store this updated value, and emit an event indicating the change in assets. The function should be accessible only to authorized entities (e.g., Depository).",
        "url": 466
    },
    {
        "nl_input": "The query requires a function to transfer advisor tokens to an advisor wallet, ensuring specific conditions are met, such as time locks, supply availability, and vesting checks. The function should handle token minting and update the advisor supply accordingly. It must also include ownership verification and proper approval clearance for the transfer.",
        "url": 467
    },
    {
        "nl_input": "The query requires a function that allows the owner to transfer ERC20 tokens to a multi-signature vault. The function should take the contract address of the ERC20 token as a parameter and transfer the balance of tokens from the current contract to the specified multi-signature vault address.",
        "url": 468
    },
    {
        "nl_input": "The query requires a function to approve the transfer of tokens and call another contract in one step. It needs parameters for the recipient contract, token amount, and extra data. The function should update allowances, emit an approval event, and invoke a fallback function on the recipient contract.",
        "url": 469
    },
    {
        "nl_input": "The query requires a function to transfer ownership of another contract, whose current owner is the calling contract, to a specified new address. The function should ensure only the owner can call it and properly handle the ownership transfer to the valid new address.",
        "url": 470
    },
    {
        "nl_input": "The query requires a function to retrieve a list of token IDs owned by a specific address. The function should take an address as input and return an array of uint256 representing the token IDs associated with that address. This matches the functionality of the first code snippet provided.",
        "url": 471
    },
    {
        "nl_input": "The query requires implementing the functionality of ending a crowdsale, including setting sale end conditions and handling post-crowdsale actions like prize initialization or forwarding/refunding funds. It focuses on ensuring only the owner can trigger this action and that specific requirements, such as time or funding goals, are met before finalizing the crowdsale.",
        "url": 472
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on the provided wei amount. It involves determining a rate depending on the wei amount and then using this rate to compute the corresponding token amount through multiplication and division operations, ensuring accurate conversion from wei to tokens.",
        "url": 473
    },
    {
        "nl_input": "The query requires a function that allows the token owner to rename the token by updating its name and symbol after operations are completed, ensuring the audience can use the updated token contract. The function should be accessible only to the owner and trigger an event notifying of the updated token information.",
        "url": 474
    },
    {
        "nl_input": "The query requires a function to facilitate the purchase of option tokens, ensuring proper allocation based on availability and percentages (e.g., 30%, 20%, 10%). It involves specifying the buyer, amount in USD cents, and transaction hash, with iterative checks for token purchase completion. The solution must handle remaining amounts and ensure correct token distribution.",
        "url": 475
    },
    {
        "nl_input": "The query requires a function to calculate unclaimed fees of the fund manager based on gross asset value (GAV). It involves computing management fees (time-based) and performance fees (based on share price rise), then summing them for total unclaimed fees, all expressed in QUOTE_ASSET with scaling by share decimals.",
        "url": 476
    },
    {
        "nl_input": "The query requires implementing a mechanism to ensure trading is restricted until at least 3 weeks have passed since the sale closed. This involves combining functionalities like starting/stopping trading and closing the sale, while incorporating a time delay condition before trading can commence after the sale closure.",
        "url": 477
    },
    {
        "nl_input": "The query requires a function to purchase a soldier, specifying the army ID and the number of soldiers. The function should handle different prices based on the quantity of soldiers purchased (1, 10, 100, or 1000) and update the soldier count for the specified army accordingly. It must also ensure the correct payment is received before processing the purchase.",
        "url": 478
    },
    {
        "nl_input": "The query requires a function to add a minter to the list of authorized minters. The function should take an address as input, ensure it is not already a minter, and return a boolean indicating success. It must include validation to prevent adding invalid or duplicate addresses.",
        "url": 479
    },
    {
        "nl_input": "The query requires a function to initiate the distribution phase in a contract, enabling owners to claim their tokens. It involves starting the distribution for a specified token, ensuring it's whitelisted, verifying the contract balance exceeds a minimum limit, and recording distribution details such as owner count, token amount, and total distributions.",
        "url": 480
    },
    {
        "nl_input": "The query requires an internal function to remove a specific deed ID from the list associated with a given address. It involves updating ownership records, reorganizing the deeds list to maintain integrity, and decrementing the total deeds count. The function ensures the deed is correctly removed while preserving the data structure's consistency.",
        "url": 481
    },
    {
        "nl_input": "The query requires a function to return the share balance of the sender. Specifically, it needs a view function that ensures the sender's share balance is retrieved accurately, likely within a contract context where conditions such as success state or bid assignments might need to be satisfied.",
        "url": 482
    },
    {
        "nl_input": "The query requires a function to submit and reveal bid properties, including parameters like `_hash`, `_value`, and `_salt`. It involves verifying the bid's authenticity, updating auction states based on conditions such as minimum price and reveal periods, and handling bid outcomes by updating balances or closing deeds accordingly. The function ensures secure bid revelation within an auction framework.",
        "url": 483
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to add a new Sale wallet address for securely holding funds, ensuring the address is valid and returning a boolean value indicating success. The function must be restricted to the contract owner and handle the addition of the wallet address appropriately.",
        "url": 484
    },
    {
        "nl_input": "The query requires a modifier to ensure that only the designated Contractor can execute a function. This involves checking if the address of the contractor matches the sender's address to restrict access, as demonstrated by the provided code example using a require statement for validation.",
        "url": 485
    },
    {
        "nl_input": "The query requires a function to move locked tokens to the team account, executable only after a specified release time. It involves releasing tokens with proper authorization and ensuring the transfer occurs under defined conditions, likely involving token ownership and account management within a smart contract system.",
        "url": 486
    },
    {
        "nl_input": "The query requires modifying the hasEnded function to determine if a sale has ended when all tokens are sold. It should return true if either the sale time has expired or the remaining tokens reach zero, ensuring accurate reflection of sale completion based on token availability.",
        "url": 487
    },
    {
        "nl_input": "The query requires a function that returns the name of the token. The desired functionality should provide a straightforward way to retrieve the token's name as a string value when called, ensuring it is easily accessible for users or other functions within the smart contract environment.",
        "url": 488
    },
    {
        "nl_input": "The query requires a function to set the current rate for ETH/USD conversion. It needs a method within a smart contract that allows the owner to update the exchange rate, ensuring it accepts a parameter for the new rate and updates the contract's stored rate value accordingly. The function should include proper validation and access control.",
        "url": 489
    },
    {
        "nl_input": "The query requires a SafeMath divide function implementation. It needs a function that performs division between two unsigned integers, ensuring the divisor is not zero and returning the quotient. The function should handle potential errors or exceptions when dividing, maintaining safety and accuracy in mathematical operations within smart contracts.",
        "url": 490
    },
    {
        "nl_input": "The query requires a function to airdrop tokens to multiple recipients. It needs to transfer specific token amounts to a list of addresses, ensuring the sender has approved the transaction. The solution should handle whole tokens, without fractions, and include error checking to confirm successful transfers.",
        "url": 491
    },
    {
        "nl_input": "The query requires a function to refund ether to investors when invoked from a token contract. It should handle the transfer of contributed funds back to investors, adjust relevant balances, and ensure refunds are processed accurately under specified conditions. The solution must integrate seamlessly with the token's logic and maintain proper accounting of refunded amounts and investor statuses.",
        "url": 492
    },
    {
        "nl_input": "The query requires a function to perform batch transfers of ETH, distributing the same amount of Ether to multiple addresses. The solution should include a payable function that accepts an array of addresses, divides the sent Ether equally, and transfers it to each address in the list.",
        "url": 493
    },
    {
        "nl_input": "The query requires a function allowing the owner to propose an address change for themselves, which must be confirmed by a notary. The provided code examples demonstrate implementations where the owner can propose a new address, either directly or via a candidate, and trigger events or require confirmation, ensuring secure ownership transfer.",
        "url": 494
    },
    {
        "nl_input": "The query requires an interface declaration within a contract that marks or identifies a specific functionality through a boolean-returning function. The focus is on contracts that use such functions (e.g., `isPricingStrategy`, `isCrowdsale`) to indicate their role or type, providing a standardized way to identify contract capabilities.",
        "url": 495
    },
    {
        "nl_input": "The query requires a function to cancel reserved tokens, specifying the destination address and token amount. It involves validating parameters, ensuring the process hasn't ended, checking reserved token limits, updating token reservations, and emitting an event for cancellation confirmation. The function is restricted to the contract owner.",
        "url": 496
    },
    {
        "nl_input": "The query requires identifying code that enforces an \"onlyOwner\" modifier to restrict function execution to the contract owner. The relevant code should include a require statement that checks if the message sender is the owner, allowing the function to proceed only if true. This ensures exclusive access for the owner in smart contracts.",
        "url": 497
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another. It needs parameters for the sender, recipient, and token value. The function should ensure proper authorization, validate the transfer amount, and handle token balances accurately during the transaction process.",
        "url": 498
    },
    {
        "nl_input": "The query requires a function that allows users to approve another address to spend a specified amount of tokens on their behalf. The function should take two parameters: the spender's address and the amount of tokens approved for spending, and it should return a boolean indicating success.",
        "url": 499
    },
    {
        "nl_input": "The query requires a function to return funds to the curator. Specifically, it needs a mechanism where the curator can initiate a refund of all funds back to themselves, ensuring that the sender is authorized and the balance is successfully transferred. This involves a conditional check for authorization and execution of the fund transfer.",
        "url": 500
    },
    {
        "nl_input": "The query requires a function that initializes contract parameters after deployment, ensuring they are set only once and remain invariant thereafter. It should include functionality to define periods and special timestamps, with validation to prevent zero-value assignments, and must be executable separately from the constructor to simplify contract compilation.",
        "url": 501
    },
    {
        "nl_input": "The query requires a function to transfer token balances to a specified address. It needs parameters for the target address and the value to transfer, ensuring the value is positive, updating balances accordingly, and emitting a transfer event to confirm the transaction's success.",
        "url": 502
    },
    {
        "nl_input": "The query requires a function to deposit wei into an exchange contract, ensuring the sender is whitelisted. The deposited amount should be added to the sender's balance, and an event should be emitted with details of the deposit, including the token address, sender, value deposited, and updated balance.",
        "url": 503
    },
    {
        "nl_input": "The query requires a mechanism to verify that terms and conditions have been read and understood. The relevant code provides a function `termsAndConditionsAreSigned` which uses Ethereum's `ecrecover` to confirm if the message signer matches the sender, proving agreement with the terms. This satisfies the need for proof of acknowledgment of terms and conditions.",
        "url": 504
    },
    {
        "nl_input": "Description of the query's needs: The query requires a function to calculate the number of tokens that can be purchased with a specific amount of wei, along with any excess wei. This involves determining token amounts based on input wei values.\n\nTokens left: 76",
        "url": 505
    },
    {
        "nl_input": "The query requires implementing the functionality to allow a token to transfer tokens on behalf of another address using the `transferFrom()` function. It involves ensuring that the sender has sufficient allowance, deducting the transferred amount from the allowance, and executing the token transfer while returning a boolean indicating success.",
        "url": 506
    },
    {
        "nl_input": "The query requires a function to sell keys by transferring a specified amount and ensuring the contract balance is sufficient. It involves calculating the selling price, transferring tokens from the sender to the contract, and sending the equivalent value in currency back to the sender. The code should handle transactions securely and efficiently.",
        "url": 507
    },
    {
        "nl_input": "The query requires a function to return the child address associated with a given parent address. The relevant code provides a function named `returnChildAddressForParent`, which accepts a parent address as input and returns the corresponding child address by interacting with another contract at a specified address.",
        "url": 508
    },
    {
        "nl_input": "The query requires a function or modifier that allows a contract function to be callable by everyone without restrictions. The relevant code should ensure no specific caller restrictions are in place, enabling any address to interact with the function successfully. This involves using a modifier or logic that bypasses access control checks for universal accessibility.",
        "url": 509
    },
    {
        "nl_input": "The query requires a function to manage and distribute rewards, ensuring the amount is positive, deducting it from a pool balance, and adding it to the owner's rewards. It may also involve capping rewards based on balance or limits and allowing reward additions through payable functions. The focus is on reward distribution, balance management, and reward adjustments.",
        "url": 510
    },
    {
        "nl_input": "The query requires a function to validate sale parameters, specifically checking if the sale kind and expiration time are valid. It ensures auctions have a set expiration date, returning a boolean indicating parameter validity. The focus is on verifying conditions for different sale types and ensuring logical constraints are met.",
        "url": 511
    },
    {
        "nl_input": "The query requires a function to check if a given rate is within specified limits. It needs a boolean return indicating validity, using predefined minimum and maximum rate constants. The focus is on an internal function that ensures the rate falls between these limits, as described in the provided code examples.",
        "url": 512
    },
    {
        "nl_input": "The query requires a function to retrieve the token balance owned by a specific address (owner). The function should take an address as input and return the number of tokens associated with that address. This is typically implemented in ERC-20 token contracts using a mapping to store balances and a `balanceOf` function for querying.",
        "url": 513
    },
    {
        "nl_input": "The query requires a function to determine if one value is equal to or greater than another. It needs two input parameters (a and b) and should return a boolean indicating whether the first value (a) is greater than or equal to the second value (b). The solution must involve a straightforward comparison operation using the greater-than-or-equal-to operator.",
        "url": 514
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer benefit funds to themselves, ensuring there are sufficient funds available and updating the balance accordingly. It involves checking fund availability, transferring funds, resetting the benefit amount, and confirming the transaction's success through an assertion.",
        "url": 515
    },
    {
        "nl_input": "The query requires logging a diary entry with a timestamp set to the current time. The code should include a function to record diary content along with the current timestamp, ensuring each entry has a unique identifier for tracking purposes.",
        "url": 516
    },
    {
        "nl_input": "The query requires a function to remove (burn) token values ranging from 123 to 120. The provided code examples demonstrate burning mechanisms where tokens are subtracted from the user's balance and total supply, with events emitted to log the burn. Specifically, it needs a function ensuring proper authorization and balance checks before burning the specified token amount.",
        "url": 517
    },
    {
        "nl_input": "The query requires a function to set the cost in cents per month for a specific contract, as indicated by the \"setCentsPerMonth\" function in the first code snippet. It needs a public function with owner restriction to update the \"centsPerMonth\" value, aligning with managing a cost parameter like \"card / watt / month\".",
        "url": 518
    },
    {
        "nl_input": "The query requires a function to approve the removal of an owner, callable only by an owner who hasn't previously initiated such a request. The function should verify conditions like owner count, request status, and time constraints, update confirmations, and execute the removal if approved by the required number of owners.",
        "url": 519
    },
    {
        "nl_input": "The query requires a function to return funds to contributors if the ICO is unsuccessful. It needs to ensure that the soft cap is not reached and the sale period is over, then transfer the invested amount back to each contributor's address, resetting their investment record and possibly logging the event.",
        "url": 520
    },
    {
        "nl_input": "The query requires a function that allows users to retrieve their assigned prize, equivalent to the total price of tokens they own. If the caller has no prize, the function should revert without consuming gas. The function must calculate the user's prize, reset token payouts, and transfer the calculated prize from a prize pool to the user.",
        "url": 521
    },
    {
        "nl_input": "The query seeks to identify the maximum investment amount accepted during a sale, expressed in wei. It requires a function or logic that defines or retrieves this maximum limit, ensuring it aligns with the sale's constraints and possibly converts values from other units (e.g., EuroCents to wei). The focus is on internal contract mechanisms managing these limits.",
        "url": 522
    },
    {
        "nl_input": "The query requires a function to transfer a specific tulip (identified by tulipId) to another address without confirmation. It warns about potential loss if the receiver's address is invalid and suggests using approve() and transferFrom() as safer alternatives. The function should take the receiver's address and tulipId as parameters, ensuring the sender owns the tulip before transferring it.",
        "url": 523
    },
    {
        "nl_input": "The query requires functions that ensure execution only after a vesting period elapses. It involves checking elapsed time against the vesting duration and potentially releasing vested tokens or amounts. The focus is on time-based conditions, such as days elapsed or periods completed, to enable specific actions post-vesting.",
        "url": 524
    },
    {
        "nl_input": "The query requires a function or logic that accepts only a value of 0.1 ether. The requirement focuses on identifying code that processes transactions or calculations specifically involving an amount of exactly 0.1 ether, ensuring precision and exclusion of other values. This involves checking for conditions where the input strictly matches 0.1 ether for execution.",
        "url": 525
    },
    {
        "nl_input": "The query requires a function to send Bankroll funds for additional dividends. It involves calculating the amount of Ether to pay, ensuring it exceeds a minimum threshold, updating the total received, and transferring the funds to the designated Bankroll address while handling potential transaction failures gracefully.",
        "url": 526
    },
    {
        "nl_input": "The query requires a function to approve token spending on behalf of the account owner. It needs parameters for the spender's address and the amount of tokens allowed to be spent, ensuring the caller has sufficient tokens. The function should update allowances, emit an Approval event, and return a boolean indicating success.",
        "url": 527
    },
    {
        "nl_input": "The query requires a function that allows the owner wallet to change the token rate. Specifically, it needs a function named setPriceRate or similar, which accepts a new rate as a parameter and can only be executed by the contract owner. This ensures exclusive control over token rate adjustments by the owner.",
        "url": 528
    },
    {
        "nl_input": "The query requires a function to distribute ERC20 tokens to holders based on a predefined ratio. The solution should iterate through a list of holders, calculate each holder's token amount according to their ratio, and transfer the tokens accordingly. It must also ensure distribution happens only once and emit an event upon completion.",
        "url": 529
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to the owner's address, ensuring the transfer is authorized and meets specific conditions. The code should include functionality for transferring token ownership, validating addresses, and potentially enforcing time constraints or restrictions on certain addresses.",
        "url": 530
    },
    {
        "nl_input": "The query requires a function to place a bet on a specific number between 0 and 36, ensuring the bet size is within predefined limits and the casino has sufficient funds. If the chosen number matches a random number generated, the player wins 36 times their bet; otherwise, they lose. The function handles invalid inputs and insufficient funds, returning appropriate messages.",
        "url": 531
    },
    {
        "nl_input": "The query requires a function to manually refund bets when the oraclize callback is not received. It needs to identify bets that are in a waiting state for oraclize, verify the bet's eligibility for refund, and return the bet amount to the player. The solution should ensure only valid bets are refunded and update the bet state accordingly.",
        "url": 532
    },
    {
        "nl_input": "The query requires setting a verification slashing period, which defines the number of blocks after the verification period during which slashing proofs can be submitted. The function should be callable only by the controller owner and ensure that the sum of the verification period and slashing period does not exceed 256 blocks. It also logs updates for the parameter change.",
        "url": 533
    },
    {
        "nl_input": "The query requires a function to set a time lock for a given allocation address, ensuring the address is valid and the timelock date is not earlier than the current time. It involves storing the timelock information and emitting an event upon successful execution. The focus is on locking mechanisms and address validation within smart contracts.",
        "url": 534
    },
    {
        "nl_input": "The query requires a function to decline token minting for a specified investor by removing their allocated tokens from the minting pool, updating the hold map, and emitting an event with the investor's address and declined token amount. The solution should ensure only the owner can perform this action.",
        "url": 535
    },
    {
        "nl_input": "The query requires a function to set the percentage for the reserved wallet in a smart contract. This involves specifying a new percentage value that will be applied to the reserved wallet, ensuring flexibility in adjusting the allocation as needed by the contract owner.",
        "url": 536
    },
    {
        "nl_input": "The query requires setting up an interface to the Blocklord (BL) contract, allowing the owner to update the contract's address through a function. The implementation should involve defining a function that accepts a new contract address, ensuring only the owner can invoke it, and updating the current BL contract interface accordingly.",
        "url": 537
    },
    {
        "nl_input": "The query requires a mechanism to ensure equal distribution of original tokens within a contract, preventing any single entity from dumping tokens, thus promoting healthy longevity. The focus is on distributing tokens evenly among participants and returning unsold tokens, as seen in the provided code snippets.",
        "url": 538
    },
    {
        "nl_input": "The query requires a function that allows the owner/seller to safely withdraw unsold tokens back to their address after a sale or auction has ended, ensuring that any remaining tokens are transferred while maintaining the balance needed for purchased but unwithdrawn amounts. The solution should prevent accidental token loss and ensure proper ownership transfer.",
        "url": 539
    },
    {
        "nl_input": "The query requires a function to update the counter of whitelisted planned contributions by subtracting the contribution about to be applied. It involves modifying a specific counter variable within a smart contract, ensuring the subtraction is accurately reflected and possibly emitting an event to notify the change.",
        "url": 540
    },
    {
        "nl_input": "The query requires setting the price for summoning a hero using Ethereum (Eth). The code should define how much Eth is needed to summon a hero, potentially adjusting prices dynamically or allowing multiple heroes to be purchased. It must include payable functionality and ensure correct pricing logic for hero summoning.",
        "url": 541
    },
    {
        "nl_input": "The query requires a function to log wallet interaction events off-chain, specifically tracking token deposits. It needs parameters for the token address, deposit amount, and updated wallet balance. The function should emit an event to record these details for off-chain analysis, facilitating wallet activity monitoring without on-chain transaction costs.",
        "url": 542
    },
    {
        "nl_input": "The query requires a mechanism for player two to approve the SlammerTime contract, triggering an event notifying player one of their intent to rumble. This involves broadcasting an approval message or event within the game context, likely using contracts to manage interactions and notifications between players.",
        "url": 543
    },
    {
        "nl_input": "The query requires identifying code that defines public functions with specific access restrictions. The focus is on modifiers or conditions that limit function accessibility, such as `onlyOwner`, `onlyEtheraffle`, or `onlyAdmin`. The result should describe the need for implementing restricted public functions in smart contracts to ensure secure and authorized usage.",
        "url": 544
    },
    {
        "nl_input": "The query requires a method to determine if an ICO is active based on a given timestamp. It needs a function that checks whether the current time falls within the ICO's start and finish times, returning a boolean value indicating if the ICO stage is active. The solution should handle optional timestamp input, defaulting to the current time if none is provided.",
        "url": 545
    },
    {
        "nl_input": "The query requires a method that can be invoked internally without explicit owner consent, specifically focusing on token purchasing. The code should allow token acquisition through an internal call, ensuring it is restricted to authorized internal functions, as demonstrated by the \"buyToken\" function being the sole caller. This ensures controlled and secure token transactions.",
        "url": 546
    },
    {
        "nl_input": "The query requires a function allowing the owner to set the number of tokens available for ICO, ensuring it remains below 70 million. The code should provide a mechanism for the owner to update the token supply before the ICO starts, with validation to prevent exceeding the maximum limit.",
        "url": 547
    },
    {
        "nl_input": "The query requires a function that returns the asset allowance from one holder to another, specifying how many tokens the spender is allowed to transfer on behalf of the owner. The function takes two addresses (_owner and _spender) as inputs and outputs the remaining approved token amount, as seen in the provided code examples.",
        "url": 548
    },
    {
        "nl_input": "The query requires a function to propose transferring ownership of the EngravedToken contract to a specified address (_engravedAddress). The function should include parameters for the new owner's address, ensure the proposal meets specific conditions (e.g., stages and timing), and update the contract's stage to \"Proposed.\"",
        "url": 549
    },
    {
        "nl_input": "The query requires a function to complete a breeding auction by bidding, ensuring the bidder owns the mating pair, verifying breeding eligibility, and confirming proper mating conditions. It involves handling breeding fees, placing bids, and executing the breeding process upon successful bid placement.",
        "url": 550
    },
    {
        "nl_input": "The query requires a function to modify a minimum value, specifically allowing adjustments to a predefined minimum amount. The function should ensure the new value is valid (e.g., greater than zero) and may include access restrictions (e.g., owner-only changes). It involves updating a state variable with the new minimum value after validation.",
        "url": 551
    },
    {
        "nl_input": "The query requires an internal function to clear the current approval and transfer ownership of a specific token ID. It needs parameters for the sender's address, receiver's address, and the token ID. The function should ensure the receiver is valid, clear any existing approval, remove the token from the sender, add it to the receiver, and emit a transfer event.",
        "url": 552
    },
    {
        "nl_input": "The query requires a function enabling the ICO contract owner to unpause the token contract. This is necessary because the ICO contract deploys the token contract, making it the default owner. The function allows the ICO owner to invoke the unpause feature on the token contract, ensuring proper control and functionality.",
        "url": 553
    },
    {
        "nl_input": "The query requires a function to place a bid in an auction using the value sent with the transaction. It needs to ensure the bid is made within the auction timeframe, verify the bid amount exceeds the current highest bid, update the highest bidder and bid amount, and emit an event indicating the increased bid.",
        "url": 554
    },
    {
        "nl_input": "The query requires a function to buy HQX tokens, ensuring the transaction is in progress and not paused. It calculates token and payment amounts based on a rate, checks issued token limits, stores tokens for the sender, emits a purchase event, transfers funds to a beneficiary, and refunds excess payments if necessary. The process also involves account restrictions and rate retrieval.",
        "url": 555
    },
    {
        "nl_input": "The query requires a function to handle unexpected funds received by the contract and ensure proceeds are paid out immediately. It needs a mechanism to withdraw specified amounts of ETH safely, transferring remaining balances if needed, while preventing transfers to invalid addresses and ensuring sufficient funds are available for operations.",
        "url": 556
    },
    {
        "nl_input": "The query requires implementing a function to batch set a quota for the user 'admin' if openTag is 0. It involves modifying or setting admin-related permissions or addresses, ensuring conditions like non-zero addresses are met, and potentially handling batch operations for approvals or spender settings. The focus is on admin management with specific constraints.",
        "url": 557
    },
    {
        "nl_input": "The query requires a function to check if a game is active based on a given game ID. It needs to verify whether the game exists and is marked as active in the system, returning a boolean value indicating the game's status. The function should involve checking conditions related to the game's ID and its active state within the contract's data structure.",
        "url": 558
    },
    {
        "nl_input": "The query requires functions for pyramid grid writing. The relevant code should involve setting multiple pixels in a grid, ensuring the operation doesn't exceed gas limits, and handling potential errors when no pixels are set. It needs to process arrays of indices and colors, interacting with a canvas structure to update pixel values efficiently within a transaction.",
        "url": 559
    },
    {
        "nl_input": "The query requires a function to return the total number of tokens in existence. The most suitable code should have a function named `totalSupply` that returns a uint value representing the total token supply. The description focuses on identifying the correct implementation of this functionality. Token count: 80.",
        "url": 560
    },
    {
        "nl_input": "The query requires a function to calculate the expected MET for a given ETH amount. It needs a method that accepts an ETH deposit amount as input and returns the corresponding MET value, likely involving a conversion rate or similar logic to determine the output based on the input amount.",
        "url": 561
    },
    {
        "nl_input": "The query requires a function to disapprove a user's KYC, setting their KYC status to false in the system. It involves updating the user's KYC status in a mapping and potentially emitting an event to notify about the change. The function should be accessible only to authorized roles, such as a KYC manager.",
        "url": 562
    },
    {
        "nl_input": "The query requires a function to unpause a smart contract, typically accessible only to specific roles like the owner or manager. The function sets the 'paused' state to false and may emit an 'Unpause' event. It ensures the contract resumes normal operations after being paused, with restrictions to prevent unauthorized access.",
        "url": 563
    },
    {
        "nl_input": "The query requires a function to sell a specific amount of tokens (0.000000000000000001 HERE) to a contract. The function should handle token subtraction from available supply, transfer tokens to the investor, and ensure proper execution within the contract's context. It involves managing token balances and transferring them accurately.",
        "url": 564
    },
    {
        "nl_input": "The query requires a function to update the maximum gas price for a transaction, accepting a parameter for the new gas price value (in Gwei) and ensuring it is greater than zero. The function should be accessible only to authorized users (e.g., the contract owner).",
        "url": 565
    },
    {
        "nl_input": "The query requires a function to handle the purchase of artworks triggered by a LikeCoin transfer callback. It should verify the transaction value, allocate artwork types to the receiver, update user and system states (e.g., IDs, sequences), and emit an event confirming the purchase details. The implementation must ensure sufficient funds and proper management of artwork inventory.",
        "url": 566
    },
    {
        "nl_input": "The query requires methods related to ICO (Initial Coin Offering) management, including starting the ICO, checking ICO stages based on timestamps, and updating ICO status when tokens are sold out. These methods ensure proper ICO operation by handling state transitions, verifying time constraints, and managing token availability across different stages.",
        "url": 567
    },
    {
        "nl_input": "The query requires a function enabling coin holders to add votes to an option in an active ballot. The vote count should equal the holder's balance, and coins must remain locked until the ballot ends. The function must validate the ballot's existence, ensure it's in progress, verify the option, and update vote counts accordingly. Timing relies on block timestamps, not external sources.",
        "url": 568
    },
    {
        "nl_input": "The query requires a modifier that restricts function execution to the pendingOwner account only, throwing an error if any other account attempts to call it. This ensures specific functions can only be executed by the designated pendingOwner, providing a layer of access control in smart contracts.",
        "url": 569
    },
    {
        "nl_input": "The query requires a function to check if a given address represents a certificate authority. The needed code should take an address as input and return a boolean value indicating whether the address is associated with a certificate authority, based on stored data about certificate authorities.",
        "url": 570
    },
    {
        "nl_input": "The query requires a function to distribute winnings (bounty and bonds) to users who provided accepted answers. It involves processing claims, verifying inputs, and paying out funds to eligible participants based on their contributions and the final outcome of a question or bet. The solution should handle multiple beneficiaries, update states, and ensure accurate fund distribution.",
        "url": 571
    },
    {
        "nl_input": "The query requires implementing token manipulations during a crowdsale process, including purchasing tokens for beneficiaries, handling unsold tokens after the sale, and minting tokens for pre-crowdsale investors. The solution should cover managing token distribution, ensuring supply limits, and executing actions before and after the crowdsale.",
        "url": 572
    },
    {
        "nl_input": "The query requires a mechanism to handle refunds if the soft cap is not reached by the end of the sale period. This involves identifying code that manages investor funds, checks if the soft cap is met, and facilitates returning invested amounts to contributors when the soft cap is not achieved. The solution should ensure proper tracking and transfer of funds during the refund process.",
        "url": 573
    },
    {
        "nl_input": "The query requires implementing a function to set the reward divisor value. The function should be accessible only to the contract owner and allow updating the reward divisor dynamically. This ensures flexibility in adjusting the divisor as needed without altering other contract functionalities.",
        "url": 574
    },
    {
        "nl_input": "The query requires creating a new series with specific parameters: a unique node hash, series name, root hash, and initial count. The function ensures the sender owns the node hash, the root hash is valid, and the series doesn't already exist. Upon validation, it initializes the series details and emits an event confirming creation. Only relevant code from the provided snippets should be considered for this task.",
        "url": 575
    },
    {
        "nl_input": "The query requires a function to return the number of coins owned by a specific address. It needs a method that takes an owner's address as input and outputs the count of coins associated with that owner, as seen in the provided code examples where similar functionality is implemented.",
        "url": 576
    },
    {
        "nl_input": "The query requires a function to conclude a specific stage, transferring tokens to designated addresses and updating the stage status. It involves operations like transferring token ownership, ensuring proper finalization, and possibly burning remaining tokens. The focus is on securely transitioning to a final or end state, ensuring all necessary actions are completed post-crowdsale or genesis stage.",
        "url": 577
    },
    {
        "nl_input": "The query requires a function that allows proposing an oracle, callable by a \"maker,\" with parameters including an IPFS hash for bug information and a taker's address. The function should handle balance checks, deduct fees, store the proposal, and emit an event upon successful proposal creation.",
        "url": 578
    },
    {
        "nl_input": "The query requires a function to set a new owner for a proxy contract while removing the old owner. It needs to accept the new owner's address as a parameter and update the ownership accordingly, potentially emitting an event to log the change for transparency and tracking purposes.",
        "url": 579
    },
    {
        "nl_input": "The query requires a function allowing users to donate tokens to a manufacturer's pool. The relevant code should include functionality to specify the manufacturer, validate the donation amount, transfer tokens from the donor to the manufacturer's pool, and emit an event confirming the deposit. Security checks ensure valid inputs and authorized operations.",
        "url": 580
    },
    {
        "nl_input": "The query requires a function to retrieve the token balance of a specific user. It should take the user's address as input and return the balance associated with that address. The function needs to be accessible externally and ensure proper handling of user data while providing an efficient way to check balances.",
        "url": 581
    },
    {
        "nl_input": "The query requires a function to revoke freeze permissions for specified wallet addresses. The relevant code should allow an owner to modify the permission status, specifically setting it to false, for wallets to freeze tokens. This involves iterating through a list of wallet addresses and updating their permission status while emitting an event for each change.",
        "url": 582
    },
    {
        "nl_input": "The query requires a function that handles incoming fund transfers to a smart contract, potentially involving interactions with external contracts or users. It should include logic for transferring funds and possibly notifying the recipient contract about the transfer, ensuring the operation's success is indicated.",
        "url": 583
    },
    {
        "nl_input": "The query requires a function that allows the owner to withdraw unsold tokens after an auction ends. The function should ensure only the owner can initiate this action and calculate the number of leftover tokens based on the total tokens and the amount sold during the auction, transferring them to a specified recipient.",
        "url": 584
    },
    {
        "nl_input": "The query requires a function to calculate the conversion of fees to tokens, allowing for future updates in the controller. It needs to consider contributed amounts, previous supply, initial supply, and total fees to determine the new token quantity based on specific calculations. The function should be adaptable for potential changes in its logic or parameters.",
        "url": 585
    },
    {
        "nl_input": "The query requires a function to approve a new borrower by adding their address to the approved list. The function should be callable only by the contract owner and set the borrower's approval status to true. This ensures that the specified address is recognized as an approved borrower within the system.",
        "url": 586
    },
    {
        "nl_input": "The query requires a function to lookup the current token price. It needs a mechanism to determine the price based on certain conditions, such as time deadlines or stages, and may involve updating or calculating the price dynamically within a smart contract environment. The function should return the current token price as a uint value.",
        "url": 587
    },
    {
        "nl_input": "The query requires a function to return the total number of games. The relevant code should have a function that calculates or retrieves the count of games stored, likely from an array or list named \"games\". The desired output is a single numeric value representing the total game count.",
        "url": 588
    },
    {
        "nl_input": "The query requires identifying code that implements a function to declare an interface marker, returning a boolean value of true. This is used to indicate compliance with a specific strategy or sale interface, as seen in the provided contracts where functions like `isCrowdsale()` and `isPricingStrategy()` serve as markers for respective interfaces.",
        "url": 589
    },
    {
        "nl_input": "The query requires a function to retrieve the value of the \"paused\" contract variable. It needs a public getter method that returns the current state of the \"paused\" boolean variable, allowing users to check if the contract is paused without modifying its state. The function should be constant and not alter the contract's storage.",
        "url": 590
    },
    {
        "nl_input": "The query requires a function to check if a given key (address) is registered. It needs a boolean return value indicating registration status. The provided code examples demonstrate functions like 'isRegistered', 'isRegisteredAccount', and 'isUserInGroup', which evaluate registration by checking non-zero values or existence in a mapping. The requirement focuses on implementing such functionality for the given key.",
        "url": 591
    },
    {
        "nl_input": "The query requires a function to check or modify the status of a sale or action. It needs to return or update details such as active status, confirmations, expiration, triggered actions, target addresses, or values. The focus is on functions like 'saleStatus', 'getActionStatus', or 'activateICOStatus' that handle status-related information in contracts.",
        "url": 592
    },
    {
        "nl_input": "The query requires a function to check a user's REB balance tier based on their token holdings. It should take the user's address as input and return a string indicating the balance tier (e.g., Platinum, Gold, Titanium, Free, or no REB). The function needs to evaluate the balance against predefined thresholds to determine the appropriate tier.",
        "url": 593
    },
    {
        "nl_input": "The query requires a function to create a new promo Team with a specified name, price, and assign it to an address. The function should handle cases where the owner address is not provided and ensure the price is valid, creating the team accordingly. It involvespromo team creation logic with owner and price validation.",
        "url": 594
    },
    {
        "nl_input": "The query requires a function to pay the creator upon successful completion. The function should verify success, ensure payment hasn't been made, transfer ether and tokens to the creator, burn excess tokens, and record transactions. It must handle both successful and unsuccessful outcomes by transferring appropriate token amounts.",
        "url": 595
    },
    {
        "nl_input": "The query requires overriding the 'getRate' function to integrate with an external rate provider. The function should dynamically fetch the rate based on the sender, sold tokens, and a given value. It involves interaction with a 'rateProvider' contract to obtain the rate, ensuring flexibility and external dependency for rate calculation.",
        "url": 596
    },
    {
        "nl_input": "The query requires a function to transfer remaining funds to a specified wallet after the contract concludes. It ensures that the balance is sent to the designated address, such as a team or project wallet, and may include conditions to confirm the contract's completion or specific states before executing the fund movement.",
        "url": 597
    },
    {
        "nl_input": "The query requires a function that allows a token holder to authorize another address to spend a specified amount of tokens on their behalf. The function should take the spender's address and the amount or value as parameters and update the allowance accordingly, ensuring the spender is authorized to use the tokens as approved.",
        "url": 598
    },
    {
        "nl_input": "The query requires a function to set or calculate the rate of FARM tokens per 1 ETH, considering the transaction time and pricing program. It needs a mechanism to update this rate dynamically, potentially adjusting based on certain conditions like total supply or balance thresholds, ensuring flexibility in token pricing.",
        "url": 599
    },
    {
        "nl_input": "The query requires a function to facilitate immediate refunds for users. It should verify the eligibility for refunds, deduct the refund amount from the user's balance, and transfer the funds back to the user's address while possibly handling fees and ensuring the refund is only claimed once. The solution must include necessary checks and state updates to maintain consistency.",
        "url": 600
    },
    {
        "nl_input": "The query requires a function to manage token purchases based on a given price. It involves receiving payment, calculating the number of tokens to issue according to the price, updating balances, transferring funds to a beneficiary, and ensuring proper event logging for transparency and accuracy in token distribution.",
        "url": 601
    },
    {
        "nl_input": "The query requires setting the historical balance for an owner's address based on snapshot indexes within a specified range. It involves parameters like the owner's address, start and end of the snapshot index range, and the balance value. The function ensures valid inputs and updates the historical balances accordingly across different levels of snapshots.",
        "url": 602
    },
    {
        "nl_input": "The query requires a function to validate arguments for changing signature requirement parameters, ensuring the new requirements are within acceptable limits. It needs to check if the new required value is not zero, and if it doesn't exceed the possible number of signers minus two, returning a boolean result and logging errors if conditions aren't met.",
        "url": 603
    },
    {
        "nl_input": "The query requires a function to calculate the amount of tokens released for a vesting schedule, given the token address, granter address, and vester address. It needs to return the number of tokens available based on the vesting details stored in a mapping or internal calculation logic.",
        "url": 604
    },
    {
        "nl_input": "The query requires a function that returns the total supply of tokens, assuming it cannot exceed the maximum value of uint256 (2^256 - 1). The function should be publicly accessible and constant, ensuring no modifications to the state, with the return type as uint256.",
        "url": 605
    },
    {
        "nl_input": "The query requires a function to retrieve statistics, specifically from a contract. It needs a method that returns multiple statistical values, such as total contribution, supply, and a boolean flag (e.g., purchasingAllowed). The function should be publicly accessible and constant, ensuring no state changes occur during execution.",
        "url": 606
    },
    {
        "nl_input": "The query requires a function to reset all balances to 0 and set the state to false. Specifically, it involves iterating through a list of addresses, setting their associated balances and airdrop values to 0, and resetting boolean states like \"filled\" and \"airdropped\" to false. Additionally, it emits an event indicating the cleanup action with the count of addresses processed.",
        "url": 607
    },
    {
        "nl_input": "The query requires a token purchase mechanism with integrated anti-money laundering (AML) and Know Your Customer (KYC) checks. It needs to verify purchasers through server-side signatures, ensuring they have completed KYC. The system should also enforce purchase limits (min/max ETH) to comply with AML regulations, using cryptographic verification for security.",
        "url": 608
    },
    {
        "nl_input": "The query requires a function to set news content, allowing the owner to update a string variable and emit an event upon successful update. The relevant code defines a function named `setNews`, which takes a string parameter `_news`, updates the `news` variable, emits a `NewsPublished` event, and returns a boolean value indicating success.",
        "url": 609
    },
    {
        "nl_input": "The query requires a function to transfer the balance from a sale auction contract to the ZodiacCore contract. The code should handle the transfer of funds, ensuring the correct balance is sent and possibly including conditions or checks before executing the transfer. It involves managing balances, verifying states, and executing the transfer to the specified contract address.",
        "url": 610
    },
    {
        "nl_input": "The query requires a function to terminate a contract and remove it from the blockchain state, typically accessible only by an authorized entity such as the contract owner. This involves using a self-destruct mechanism to eliminate the contract's code and release any associated resources or funds.",
        "url": 611
    },
    {
        "nl_input": "The query requires a function to delete or remove data when bugs occur. Specifically, it needs a self-destruct mechanism for contracts or a method to delete mappings and auction entries. The implementation should ensure that unwanted or erroneous data is effectively removed or contracts are terminated securely.",
        "url": 612
    },
    {
        "nl_input": "The query requires a function to request a certification document by its index, which is a paying feature. The needed code should handle payment verification and return the certification document associated with a specific student and index. This involves checking if the fee is paid and retrieving the document from stored data.",
        "url": 613
    },
    {
        "nl_input": "The query requires a function to verify if an address is an investor. It needs to check whether a given address exists in a list or mapping of investors and return a boolean value indicating the presence of the investor. The function should efficiently determine investor status by iterating through a list or accessing a mapping structure.",
        "url": 614
    },
    {
        "nl_input": "The query requires a function to retrieve comprehensive information about a match, including team names, amounts, participants, win index, match completion status, minimum bet amount, match number, and betting status. The most relevant code provides a function returning these details, fulfilling the query's need for match state and related data.",
        "url": 615
    },
    {
        "nl_input": "The query requires a function to transfer tokens to a specified address, replacing msg.sender with tx.origin. It ensures the transfer logic uses tx.origin instead of msg.sender for authorization and balance checks, allowing token transfers initiated by the transaction's originator rather than the immediate sender.",
        "url": 616
    },
    {
        "nl_input": "The query requires a function allowing the contract owner to transfer out any accidentally sent ERC20 tokens, excluding the specific token intended for the contract. The function should ensure only the owner can initiate transfers and prevent the withdrawal of the contract's primary token by specifying an exclusion condition.",
        "url": 617
    },
    {
        "nl_input": "The query requires updating the `startTimestamp` property with a new `_start` value, ensuring the new value is within valid time constraints (after current time and before `endTimestamp`). The update should also log the old value and the change through an event named `StartTimestampUpdated`.",
        "url": 618
    },
    {
        "nl_input": "The query requires creating a new offer with a specific setting. It needs a function that accepts a 'setting' parameter, ensures it's greater than zero, and likely involves a payable transaction. The most relevant code should include functionality to internally process the offer creation based on the provided setting.",
        "url": 619
    },
    {
        "nl_input": "The query requires a function to transfer token balance from the sender's address to a specified address (_to) with additional data (_data). It involves checking balance sufficiency, value validity, and whether the recipient is a contract. If conditions are met, it executes the transfer and returns success.",
        "url": 620
    },
    {
        "nl_input": "The query requires a function to set the current DOL prices, allowing the owner to update both selling and buying prices. The function should be secure, ensuring only the authorized owner can modify the prices, and it must accept two parameters: one for the new sell price and another for the new buy price.",
        "url": 621
    },
    {
        "nl_input": "The query requires a function to add a Kin token vesting grant. It involves creating a vesting schedule, associating it with a specific token, granter, and vester, and enabling the calculation of vested tokens over time. The solution should allow unlocking vested tokens by the beneficiary and ensure proper balance updates.",
        "url": 622
    },
    {
        "nl_input": "The query requires a function to freeze tokens at a specified address, with parameters including the target address, token amount, and release date. It ensures the sender has sufficient balance, updates token balances and freezing records, and emits events for transfer and freezing actions. Gas usage is noted as non-deterministic based on existing freezes for the address.",
        "url": 623
    },
    {
        "nl_input": "The query requires a function to retrieve all relevant information about a specific waifu using its unique token ID. This includes the waifu's name, selling price, and owner's address. The function should be publicly accessible and provide these details in a view-only manner without modifying the contract state.",
        "url": 624
    },
    {
        "nl_input": "The query requires a function to assign a new address to the CEO role, ensuring the new address is not null. The function should only be executable by the current CEO and update the 'ceoAddress' variable with the new address provided as an argument. This ensures proper authorization and prevents assignment to an invalid address.",
        "url": 625
    },
    {
        "nl_input": "The query requires a function to retrieve the released token amount for a specified address. It needs a method named `releasedTokenOf` that takes an address as input and returns the corresponding uint256 value representing the token amount released to that address. This function should be publicly accessible and not modify the contract state.",
        "url": 626
    },
    {
        "nl_input": "The query requires a function implementing the logic for a predator attack in a game scenario. The predator can kill up to 10 animals, or up to 10% of the animal population if fewer than 100 animals exist. The function should determine the number of animals killed based on population size, generate random selections, and handle associated game mechanics like distributing rewards and triggering subsequent attacks.",
        "url": 627
    },
    {
        "nl_input": "The query requires a function to extend the ICO end date. The code should allow modification of the ICO end date after its initial setting, ensuring flexibility in managing ICO duration. It must include functionality to update the ICO end date while maintaining security and access restrictions.",
        "url": 628
    },
    {
        "nl_input": "The query requires a function that allows a pre-approved user to take ownership of a specific color, identified by its token ID. The function should verify the new owner's approval and ensure the old owner exists before transferring ownership. It involves checking sender permissions, validating approvals, and executing the ownership transfer securely.",
        "url": 629
    },
    {
        "nl_input": "The query requires a function that sends pooled Ether to a specified address, calculates unused Ether for refund, and advances the contract stage. It needs conditions for minimum contribution, ensures correct balances, handles refunds if necessary, and progresses the contract state after transferring funds.",
        "url": 630
    },
    {
        "nl_input": "The query requires a function that retrieves connection details, including entity active status, connection fields (active, data, direction, expiration), and related addresses. It involves resolving entity addresses, accessing storage for entity and connection information, and returning these details as a tuple for specified entities and connection types.",
        "url": 631
    },
    {
        "nl_input": "The query requires a code implementation that ensures certain actions can only be performed when an agreement is not locked. This involves using a modifier to check the locking status and allow execution only if the agreement is unlocked, typically through a boolean variable indicating the lock state. The provided codes demonstrate examples of such modifiers.",
        "url": 632
    },
    {
        "nl_input": "The query requires a function to check if a sequence can be represented in the form of \"48151623420...00\". The needed function should take a sequence, offset, and length as inputs, iterate through the specified range, and determine if the sequence matches the pattern multiplied by powers of 10, returning the matching index or -1 if no match is found.",
        "url": 633
    },
    {
        "nl_input": "The query requires calculating the fee from the losing portion of the total pot. It involves determining the remaining amount after subtracting the winners' pot from the total pot, then computing a fee based on a percentage of this remaining amount, and finally deducting the fee from the remaining balance. The calculation ensures no fee is applied if there's no losing portion.",
        "url": 634
    },
    {
        "nl_input": "The query requires updating network constants when necessary. Specifically, it involves modifying a parameter like 'pricePerMessage' through a function that ensures only authorized users can make changes and logs updates. The requirement focuses on maintaining flexibility in network settings by allowing adjustments to key constants under specific conditions.",
        "url": 635
    },
    {
        "nl_input": "The query requires a function to perform the initial token allocation between founders' addresses, ensuring it is executed only once after contract deployment. It involves transferring specific token amounts to designated addresses such as founders, support, and bounty addresses. The solution should include a mechanism to prevent re-execution and ensure proper allocation.",
        "url": 636
    },
    {
        "nl_input": "The query requires a function that creates and stores a new promise object with specified recipient, amount, and locked time, while updating the promisedTokenBalance. It involves managing token balances, ensuring state transitions, and logging the creation of the promise. The function should handle validations and maintain the integrity of token promises.",
        "url": 637
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another using an allowance mechanism. Specifically, it needs to verify the sender's allowance, deduct the transferred amount from the allowance, and execute the token transfer, ensuring proper authorization and updating balances accordingly.",
        "url": 638
    },
    {
        "nl_input": "The query requires a batch transfer function that sends tokens to multiple receivers with specified amounts from the owner's balance. It needs parameters for an array of receiver addresses and corresponding token values, ensuring the lengths match and limiting the number of addresses. The function should return true upon successful execution.",
        "url": 639
    },
    {
        "nl_input": "The query requires a function to return the total supply of a token. The provided code snippets demonstrate implementations of the `totalSupply()` function, which returns the total number of tokens in circulation (e.g., `totalSupply`, `numTokens`, or `_totalSupply`). The function is typically public, constant, and returns a uint256 value representing the token supply.",
        "url": 640
    },
    {
        "nl_input": "The query requires a function to initiate a crowd-sale, allowing the owner to start it manually, either before the specified date or after a stop. The function should ensure prerequisites are met (e.g., presale conclusion) and define phase-specific blocks for the crowd-sale timeline. It must also update relevant state variables and emit events as needed.",
        "url": 641
    },
    {
        "nl_input": "The query requires a function to remove or delete a contract. The description indicates the need for a method that either deactivates a contract address from an active list or performs self-destruction of the contract itself. The provided code examples include functions to deactivate a contract, remove seller information, or perform self-destruction.",
        "url": 642
    },
    {
        "nl_input": "The query requires a function to update the coldwallet2 address, ensuring the new address is not zero. It needs an implementation with a restriction allowing only the contract owner to perform this change, as seen in the provided code examples where similar wallet-changing functions are restricted to the owner.",
        "url": 643
    },
    {
        "nl_input": "The query requires a function to pay using mileage points. The user needs a mechanism where a specified amount of mileage points is deducted from the user's balance to summon heroes based on random values, ensuring the sender has sufficient mileage points and the amount is within allowed limits (1-5).",
        "url": 644
    },
    {
        "nl_input": "The query requires a function to approve a proxy for token transfers, allowing a specified address to transfer tokens on behalf of the owner. The function should take the spender's address and the amount or token ID as parameters, update the allowance, and emit an Approval event to confirm the approval.",
        "url": 645
    },
    {
        "nl_input": "The query requires a function to check if a given zodiac is ready to breed, ensuring the zodiac's siringWithId is 0 and its cooldownEndBlock has passed. This involves verifying specific conditions related to breeding eligibility within the blockchain contract logic.",
        "url": 646
    },
    {
        "nl_input": "The query requires a function to deposit funds into a contract. Specifically, it needs to handle Ether (wei) deposits, ensure the sender is authorized (whitelisted), update the token balance for the sender, and emit an event with details of the deposit. The solution should involve payable functions and proper state updates while adhering to security requirements.",
        "url": 647
    },
    {
        "nl_input": "The query requires a method that allows anyone to withdraw funds to the coindrops wallet after a specified locking period. The method should ensure the locking period has ended, perform the transfer of tokens, and update the status to prevent further withdrawals. It involves checking time constraints and executing a token transfer operation.",
        "url": 648
    },
    {
        "nl_input": "The query requires a function to concatenate two strings, returning a new string that combines both inputs. It should take two string slices as parameters and return their concatenation as a newly allocated string, ensuring efficient memory usage and proper handling of string lengths during the process.",
        "url": 649
    },
    {
        "nl_input": "The query requires executing a multi-signature transaction from a wallet using two signers: one from msg.sender and the other derived via ecrecover. It involves signing a hash of transaction details (toAddress, value, data, expireTime, sequenceId) and validating the signature within a specified expiration time to prevent replay attacks, ensuring transaction uniqueness through sequence IDs.",
        "url": 650
    },
    {
        "nl_input": "The query requires a function to issue unlocked tokens to a specified address with a given value. The function should be callable by an admin and return a boolean indicating success. It involves token issuance without locking mechanisms, ensuring immediate availability of tokens for the recipient.",
        "url": 651
    },
    {
        "nl_input": "The query requires a function to handle dividend payments by adding incoming funds to the dividend pool. It should include functionality to record the dividend amount, update dividend lists with proportional values based on total supply, increment dividend counters, and emit events indicating available dividends. The solution must ensure non-zero payments and proper state updates.",
        "url": 652
    },
    {
        "nl_input": "The query requires a function to disable the whitelist state in a smart contract. It should set the whitelist status to false, emit an event indicating the change, and return the updated whitelist state. The function must only be callable by the contract owner.",
        "url": 653
    },
    {
        "nl_input": "The query requires a function that can only be called after the presale has concluded. It should handle finalization tasks, such as forwarding funds or enabling refunds, ensuring specific conditions are met (e.g., presale goals reached, current time exceeds closing time). The function must include safeguards to prevent unauthorized or premature calls.",
        "url": 654
    },
    {
        "nl_input": "The query requires a function to cancel any pending multisig call, ensuring only authorized users can perform the cancellation. If no call is pending, it should notify that there's nothing to cancel. Otherwise, it cancels the call, resets related data, and confirms the cancellation.",
        "url": 655
    },
    {
        "nl_input": "The query requires a function to transfer all Ether held by the contract back to the owner, including any fees. The provided code examples demonstrate implementations where the contract's entire balance is sent to the owner's address, ensuring full refund functionality. The requirement focuses on a secure method for the owner to reclaim Ether.",
        "url": 656
    },
    {
        "nl_input": "The query requires public methods named \"give\" and \"take\" that can only be called by owners. These methods likely involve transferring ownership or assets, ensuring only authorized users (owners) can execute them, as indicated by modifiers like \"onlyOwners\" or \"onlyOwner\" in the provided code samples. The focus is on restricting method access to authorized entities.",
        "url": 657
    },
    {
        "nl_input": "The query requires a function to issue tokens to users, transferring them from a deposit or balance. It needs an internal or external function that handles token issuance by updating balances or transferring tokens to beneficiaries, ensuring proper validation and subtraction of issued amounts from the available deposit or balance.",
        "url": 658
    },
    {
        "nl_input": "The query requires a mechanism to create tokens that are only usable during an active sale period. The solution should involve functions that manage token sales, ensuring tokens are purchased within the sale timeframe, with constraints on the number of tokens per transaction and total supply. Additionally, it should handle pricing dynamics based on the quantity sold.",
        "url": 659
    },
    {
        "nl_input": "The query requires adding a property or functionality related to handling payments or values in a contract. It likely involves incorporating a payable function to manage rewards, dividends, or similar financial additions, ensuring non-zero value transactions and possibly updating states like dividend amounts or reward pools. The exact implementation should align with the contract's purpose and maintain proper accounting.",
        "url": 660
    },
    {
        "nl_input": "The query requires a function allowing the factory owner to withdraw any ERC20 asset tokens from the contract. The function should specify the token address and amount, ensure only the owner can initiate the transfer, and confirm successful execution of the token withdrawal.",
        "url": 661
    },
    {
        "nl_input": "The query requires a function to seal the Crowdsale upon its completion, ensuring it cannot be altered afterward. It needs a mechanism to verify if the Crowdsale has ended, perform finalization tasks (e.g., transferring funds or minting tokens), and set a flag (e.g., isFinalized) to true, preventing further changes.",
        "url": 662
    },
    {
        "nl_input": "The query requires a function to retrieve the total supply of tokens in a contract. It should be a view or constant function named \"totalSupply\" that returns a uint256 value representing the total number of tokens. The function must efficiently provide the current token supply without altering the contract's state.",
        "url": 663
    },
    {
        "nl_input": "The query requires a function that enables users to cancel their adoption request. Specifically, it should verify the existence of the request, ensure the requester initiates the cancellation, refund any associated fees, and emit an event confirming the cancellation. The provided code snippet matches this requirement by allowing a user to cancel an adoption request for a specific cat ID.",
        "url": 664
    },
    {
        "nl_input": "The query requires an internal function for creating, accepting, and adding additions to a request from a payer. It involves processing request data, validating payee and payer information, calculating expected amounts, handling fees, updating addresses, creating a request ID, storing Bitcoin addresses, and managing additions. The function ensures security checks and proper value handling.",
        "url": 665
    },
    {
        "nl_input": "The query requires a function to calculate the amount of tokens a sender is purchasing based on the input value (in wei). It involves determining token amounts across different stages or events, applying specific rates, and handling limits or caps. The function should account for various scenarios, such as private sales, public events, and discounts, ensuring accurate token allocation.",
        "url": 666
    },
    {
        "nl_input": "The query requires implementing functionality to handle variable-length arrays, specifically focusing on length validation and manipulation. It involves checking if a string's length falls within a specified range or concatenating strings dynamically. The solution should ensure proper memory allocation and accurate length management for efficient array handling in smart contracts.",
        "url": 667
    },
    {
        "nl_input": "The query requires a smart contract function to set up a token sale, including initial date and token address configuration. It ensures the token's total supply is zero and verifies contract ownership. The setup initializes sale stages and durations, preparing the contract for the token sale process.",
        "url": 668
    },
    {
        "nl_input": "The query requires a function that allows the owner to lock a specific feature or state within a contract. The desired functionality should include a mechanism to set a lock, potentially with conditions to ensure it can only be locked if not already locked, and may involve emitting an event to notify about the lock status change.",
        "url": 669
    },
    {
        "nl_input": "The query requires a function to create a company with specified parameters: name, owner, and price. The function should ensure the price is divisible by 100, create a new company entry, assign a unique ID, set the price, and transfer ownership with total shares. It must also emit an event indicating the company's creation details.",
        "url": 670
    },
    {
        "nl_input": "The query requires setting the cooldown end time for a Dog based on its current cooldown index. This involves calculating the cooldown end block using the cooldown index and updating the Dog's cooldown information accordingly. The solution should ensure proper increment of the cooldown index if it is below a specified limit.",
        "url": 671
    },
    {
        "nl_input": "The query requires a function for performing update operations within a contract. Specifically, it needs a function that updates certain parameters or settings, such as tracking operations with sender and value details, updating permissions for contract upgrades, or modifying minimum contribution requirements. The focus is on implementing update functionality with appropriate access restrictions and event emissions.",
        "url": 672
    },
    {
        "nl_input": "The query requires a function to assign proceeds from a buyout, distributing funds to the current owner, beneficiaries, referrers, and updating fees and prize pools accordingly. It involves handling multiple payments, considering referral bonuses, and ensuring correct fund allocation based on specific percentages and conditions.",
        "url": 673
    },
    {
        "nl_input": "The query requires a function to retrieve the RDN price in WEI during an auction at the time of function call. It needs to consider if the region is owned or has a current buyer, adjusting the price accordingly with minimal raise or starting price. Additionally, it should dynamically update prices based on predefined growth rates and conditions.",
        "url": 674
    },
    {
        "nl_input": "The query requires a function to approve the transfer of a specified amount of tokens from the transaction creator to a recipient. It involves setting an allowance for a spender address and emitting an approval event, ensuring the spender can withdraw up to the approved amount from the owner's account.",
        "url": 675
    },
    {
        "nl_input": "The query requires a modifier that ensures a function can only be executed during the crowdsale period. Specifically, it needs to verify whether the current state is within the PreFunding or Funding phase, allowing execution only if the crowdsale is active as per defined conditions. This ensures proper timing control for crowdsale-related operations.",
        "url": 676
    },
    {
        "nl_input": "The query requires a function to set an address value, ensuring it is not zero, as seen in the provided code examples where addresses are updated with non-zero validation. The requirement involves a contract function with access control, allowing specific roles (e.g., Contract Owner or Admin) to modify the address parameter securely. The result should include a modifier or permission check for restricted access.",
        "url": 677
    },
    {
        "nl_input": "The query requires locking the DAICO supply until a specific timestamp (2018-09-01 14:00:00). The relevant code should implement a lockup mechanism for a specific address until the given time, ensuring the supply cannot be transferred before the specified date. It involves setting a lockup time and emitting an event to confirm the lockup.",
        "url": 678
    },
    {
        "nl_input": "The query requires a mechanism to adjust gas reimbursement during token transfers when the sender's account balance falls below a minimum threshold. It should include a function to set or modify this gas value, ensuring it is within a specified limit, and must only be adjustable by an authorized entity (e.g., contract owner).",
        "url": 679
    },
    {
        "nl_input": "The query requires a function to transfer tokens from the owner to another address during an ICO. It needs to ensure the ICO is active, validate the recipient address, check sufficient balance, and update balances accordingly. The function should also emit a transfer event upon successful execution.",
        "url": 680
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another, utilizing the contract's balance and ensuring proper subtraction and addition of tokens for the involved addresses. The function should handle token allowances and emit a 'Transfer' event with relevant details, confirming successful execution.",
        "url": 681
    },
    {
        "nl_input": "The query requires a function to accept ethers (msg.value) and facilitate token purchases on behalf of a user. It should include conditions to validate the transaction, calculate tokens based on ether value, update balances, and transfer funds to the appropriate wallet while ensuring the beneficiary address is valid.",
        "url": 682
    },
    {
        "nl_input": "The query requires a function to return \"truth\" (true) if the given account is allowed to buy tokens. It needs to ensure the account is not frozen, the transaction value is positive, and possibly validate balances or token conditions before confirming the purchase eligibility.",
        "url": 683
    },
    {
        "nl_input": "The query requires a function to check if a specified project has been canceled. It needs a getter method that takes a project ID as input and returns a boolean value indicating whether the project is canceled. The method should handle project hierarchies and admin types to accurately determine cancellation status.",
        "url": 684
    },
    {
        "nl_input": "The query requires a function or modifier that checks if the market maker contract instance is open for public access. Specifically, it needs a mechanism (e.g., modifier or function) to ensure that a market maker contract associated with a token allows public interaction only when explicitly opened for public use.",
        "url": 685
    },
    {
        "nl_input": "The query requires a function to update a sequence value at the next snapshot, ensuring that the value is stored only if it differs from the previous one or belongs to a new snapshot. It involves managing snapshots, checking for unmodified values, and updating or deleting entries in a storage array as needed.",
        "url": 686
    },
    {
        "nl_input": "The query requires a function that allows callers to send ether to a Campaign contract and have CampaignTokens generated in a chosen address. It involves handling payments, token allocation based on contributed amounts, and potentially managing bonuses or KYC requirements depending on the contribution size and time constraints.",
        "url": 687
    },
    {
        "nl_input": "The query requires a function that determines if a given promise can be collected by the recipient, based on its state (confirmed or pending) and whether the current block timestamp is beyond the locked period. The function should return a boolean value indicating the possibility of collection.",
        "url": 688
    },
    {
        "nl_input": "The query requires identifying code that checks if the current block number is greater than or equal to a predefined start block, ensuring a process has begun. It involves a function returning a boolean value to confirm whether the start condition based on block numbers has been met. This focuses on block-based timing rather than absolute time.",
        "url": 689
    },
    {
        "nl_input": "The query requires a function that allows the admin to finalize a sale, ensuring allocations are completed. It should include conditions to verify the sale's completion criteria, handle token or balance distributions, and possibly manage reserve balances or refunds. The function must be secure, potentially using modifiers like \"onlyOwner,\" and ensure proper state updates post-finalization.",
        "url": 690
    },
    {
        "nl_input": "The query requires a function to withdraw tokens under specific conditions. It should ensure that tokens are withdrawn only after certain criteria are met, such as the crowdsale ending or being finalized, and handle cases like transferring unbought tokens back to the seller or withdrawing mistakenly transferred tokens to a beneficiary address. The solution must include proper authorization and balance checks.",
        "url": 691
    },
    {
        "nl_input": "The query requires a function to facilitate token purchases on behalf of a benefactor, logging payment events, and forwarding funds to a multisig wallet. It involves handling identifiers, ensuring non-zero values for benefactors and amounts, updating purchase records, and managing token allocations while maintaining accurate accounting of transactions.",
        "url": 692
    },
    {
        "nl_input": "The query requires a function that prepares compression data and triggers an event for buy or reload transactions, involving parameters such as player ID, team, ether amount, keys, and event data. It compresses data and IDs, then emits an event with detailed transaction information, including sender, amounts, and associated addresses.",
        "url": 693
    },
    {
        "nl_input": "The query requires a function to permanently stop the minting of tokens. The most suitable code provides a `finishMinting` function that sets a boolean `isMintingFinished` to true, preventing further minting and recording the date when minting stopped. This function ensures token minting cannot occur after it is called.",
        "url": 694
    },
    {
        "nl_input": "The query requires a function to add a bonus to a specific block, involving coordinates (x, y) and a bonus value. It ensures the bonus amount does not exceed the available balance and updates the block's bonus using a unique key. The function is restricted to primary authorization and utilizes storage for bonus management.",
        "url": 695
    },
    {
        "nl_input": "The query requires a function to set a new rate, specifically for converting TCR to ETH, ensuring it falls within a predefined range. The function should be callable only by the owner and update the rate accordingly. Among the provided codes, the requirement focuses on implementing rate updates with validation and ownership restriction.",
        "url": 696
    },
    {
        "nl_input": "The query requires a function to calculate the remaining release time of a specific stage for a given account. It involves checking the frozen accounts, identifying the target account, and determining the remaining time in the release period based on predefined time records. If the current time exceeds the release period, it returns zero.",
        "url": 697
    },
    {
        "nl_input": "The query requires a function to pay out tokens to a user. It needs to check the token balance of the sender, transfer the tokens to the sender's address, and reset the sender's balance to zero. The function should also emit an event confirming the token payout with details like the recipient, amount, and timestamp.",
        "url": 698
    },
    {
        "nl_input": "The query requires a function to transfer token ownership after the completion of a token sale. It needs to ensure that the ownership is transferred to a new address, with conditions to confirm the sale's completion and validity, as well as proper handling of balances and reserves before transferring ownership.",
        "url": 699
    },
    {
        "nl_input": "The query requires a function allowing the owner or revoke role to change the revoke address, ensuring it doesn't match the owner, admin, or ops addresses. The new revoke address must trigger a notification or event upon successful update. This ensures controlled and restricted updates to the revoke address for security purposes.",
        "url": 700
    },
    {
        "nl_input": "The query requires an admin or bankroll function to change the bankroll address. The desired functionality should allow authorized entities (admin or existing bankroll) to update the bankroll address in a secure manner, ensuring proper access control and accurate address modification within the smart contract system.",
        "url": 701
    },
    {
        "nl_input": "The query seeks a function to determine if the pre-sale period is active based on time conditions. It requires logic that checks whether the current time falls within predefined pre-sale start and end times, potentially incorporating additional conditions like a pre-sale enable flag or available pre-sale amount. The desired output is a boolean indicating if the pre-sale is ongoing.",
        "url": 702
    },
    {
        "nl_input": "The query requires a function allowing the director to open contributions, as seen in the provided code where the director can initiate or reopen a contribution period by setting a boolean value. The function should ensure only the director can execute it and confirm the contribution status change.",
        "url": 703
    },
    {
        "nl_input": "The query requires a function to create a cloned token with specified parameters (snapshot block, name, and symbol) and return the address of the cloned token. It should handle snapshot block validation and transfer control to the sender. Additional functionalities like updating token addresses or changing token wallets are not relevant to the query's needs.",
        "url": 704
    },
    {
        "nl_input": "The query requires a function that allows the contract to self-destruct and send remaining funds to the owner, ensuring control is maintained by the owner and any balance is transferred before termination. This involves a conditional check for self-destruction eligibility, transferring tokens or Ether to the owner, and executing the self-destruct operation.",
        "url": 705
    },
    {
        "nl_input": "The query requires a function to claim tokens for an economic reserve wallet, ensuring the claim is made after a specified timelock and follows a vesting schedule. The function should calculate the total unlocked tokens based on the vesting stage, update the claimed amount, and transfer the remaining tokens to the reserve wallet.",
        "url": 706
    },
    {
        "nl_input": "The query requires a function to transfer the raised amount to the company address once the stage has ended. It ensures that the transaction is initiated by the creator and confirms successful transfer of the balance to the designated company address, reverting if unsuccessful.",
        "url": 707
    },
    {
        "nl_input": "The query requires a function to calculate the asset valuation in ART token quantity based on the input amount. It needs to determine the number of tokens to transfer to an investor address depending on the invested ethers, considering different rates for specific investment tiers, and return the corresponding token amount.",
        "url": 708
    },
    {
        "nl_input": "The query requires a function to retrieve information using a specific ID. The needed code should define a function that accepts an ID as input and returns associated data. Specifically, it must locate and return values linked to the given ID, such as an identifier and its related attributes (e.g., owner, dataUrl, or gifts).",
        "url": 709
    },
    {
        "nl_input": "The query requires a function to count the number of ELHTs (or similar entities) tracked by the contract. The most relevant code should provide a function that returns the total count of specific items stored in the contract, such as 'matches' or 'games,' indicating a similar counting mechanism for the required ELHTs.",
        "url": 710
    },
    {
        "nl_input": "The query requires a function to initiate a user upon their first visit. This involves setting an initiation flag, allocating initial resources, and defining starting map coordinates for the user. The most relevant code demonstrates this by initializing resources, setting map positions, and updating total cities while ensuring the initiation happens only once per user.",
        "url": 711
    },
    {
        "nl_input": "The query requires a method to allow users with old proxy tokens to swap them for new tokens at a 1:2 ratio. The solution should involve transferring the old tokens from the user to an issuing token owner and then issuing twice the amount of new tokens to the user, ensuring the old tokens are no longer in the user's balance.",
        "url": 712
    },
    {
        "nl_input": "The query requires a function to facilitate token purchases from sellers, specifying the amount of tokens to buy. It involves calculating token prices, handling commissions, transferring tokens between buyer and seller, and updating relevant balances and counts. The function ensures proper error handling and emits events for purchase errors if necessary.",
        "url": 713
    },
    {
        "nl_input": "The query requires a function to calculate token amounts based on wei input, considering different rates for specific wei ranges. It involves converting wei to tokens using predefined rates and ensuring proper handling of Ethereum's 18-decimal precision. The focus is on logic that adjusts token output depending on the wei amount provided by users.",
        "url": 714
    },
    {
        "nl_input": "The query requires a function to remove an admin address from a system, ensuring the admin exists and isn't the message sender. The solution should involve modifying the admin status and potentially adjusting an admin list, with appropriate validations and return values to confirm successful removal.",
        "url": 715
    },
    {
        "nl_input": "The query requires a function to verify if an address is registered or verified. The needed code should include a function that takes an address as input and returns a boolean value indicating whether the address is verified or registered. This involves checking the status of the address within a predefined list or record.",
        "url": 716
    },
    {
        "nl_input": "The query requires a modifier implementation that restricts function execution to the owner only. It involves checking if the sender of the message (msg.sender) is the owner and allowing execution if the condition is met. The provided code examples demonstrate this by using a require statement to ensure only the owner can proceed.",
        "url": 717
    },
    {
        "nl_input": "The query requires a function to retrieve the total number of tokens in existence. The provided code snippets demonstrate implementations of a `totalSupply()` function, which returns the current total supply of tokens as a uint256 value. This function is public and viewable, ensuring accessibility for users or contracts needing this information.",
        "url": 718
    },
    {
        "nl_input": "The query requires a function to determine the type of token (long or short) based on a specified token address. The desired function should take an address as input and return a uint value indicating the token type, where short tokens are represented by 1 and long tokens by 2.",
        "url": 719
    },
    {
        "nl_input": "The query requires a function to check if an owner holds at least a specified amount of shares in a company. The needed code should verify the owner's shareholding against the given amount, ensuring they meet or exceed the required share threshold, as indicated by the condition `ownerAddressToShares[_owner] >= _amount`.",
        "url": 720
    },
    {
        "nl_input": "The query requires a method to check if an ICO (Initial Coin Offering) is active based on time constraints. It needs a function or modifier that verifies whether the current time falls within the ICO's start and end times, returning a boolean value or enforcing conditions accordingly.",
        "url": 721
    },
    {
        "nl_input": "The query requires determining the success of a token burning process. The provided code snippets describe functions related to burning tokens: one performs a burn operation and returns a boolean indicating success, another burns tokens from a specific address, and the third adds an entity (\"BurningMan\") with no direct burn functionality. The requirement focuses on evaluating whether the token burn was successful.",
        "url": 722
    },
    {
        "nl_input": "The query requires a function or contract that enables a \u0110App to accept Bitcoin transfers. Specifically, it needs a method to handle Bitcoin investments by associating them with an Ethereum address and equivalent value in Wei. The solution should facilitate cross-chain functionality, allowing Bitcoin to be converted or recorded as a transfer within the \u0110App's system.",
        "url": 723
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens that have vested over time. It needs to consider factors like the start day, total vesting days, and the amount of tokens allocated for vesting. The function should return the vested token count based on elapsed days compared to the total vesting period.",
        "url": 724
    },
    {
        "nl_input": "The query requires a function to calculate the token amount based on the wei amount contributed by a user, considering different rates for various contribution levels. It should handle ether conversions and ensure proper rate application, returning the corresponding token amount. The solution must account for ether's 18-decimal precision.",
        "url": 725
    },
    {
        "nl_input": "The query requires a function or modifier that throws an error if the order has expired. It needs to compare the current time with the expiration time and ensure the order is still valid, using a require statement to enforce this condition. The solution should involve checking whether the current time is beyond the specified expiration timestamp.",
        "url": 726
    },
    {
        "nl_input": "The query requires a function to claim back ether when a buy tokens request is rejected. It needs to check if the user has a balance from rejected requests, reset this balance, and transfer the ether back to the user while emitting an event for the claim action.",
        "url": 727
    },
    {
        "nl_input": "The query requires a function to transfer tokens within the Lava balances system, ensuring proper deduction and addition of token balances between specified addresses while adhering to allowed token permissions. The solution must include functionality for transferring tokens, updating balances, and confirming successful execution.",
        "url": 728
    },
    {
        "nl_input": "The query requires an internal function for handling transactions with ether. It should include functionality to withdraw ether, specifying the amount in wei, and transferring it to designated addresses or the owner. The provided code examples demonstrate variations of such functions, ensuring proper balance checks and transfers within a contract environment.",
        "url": 729
    },
    {
        "nl_input": "The query requires a function that performs an ERC20 standard token transfer, wrapped with an `activated` modifier to control its execution. The function should be part of a smart contract and ensure that the transfer logic adheres to the ERC20 standard while incorporating the activation state check before proceeding with the transfer.",
        "url": 730
    },
    {
        "nl_input": "The query requires a function to calculate (x * y) / 2^128, taking two parameters (x and y) and returning the result of their multiplication divided by 2^128. The function should handle large numbers and ensure precision in fixed-point arithmetic operations.",
        "url": 731
    },
    {
        "nl_input": "The query requires a function to handle post-ICO distribution of funds when the sale is closed and minimum token goals are met. Specifically, 10% of the funds should cover operational expenses, while the remaining 90% is distributed to the company. The function must ensure proper stages and conditions are met before executing the distribution.",
        "url": 732
    },
    {
        "nl_input": "The query requires separating a function for use by derived contracts. The focus is on identifying a function that can be reused or extended in child contracts, ensuring modularity and maintainability. This involves extracting a function that performs a specific task, such as sealing a contract, withdrawing balances, or destructing it, while allowing inheritance or reuse.",
        "url": 733
    },
    {
        "nl_input": "The query requires setting the IPFS hash of an image for a couple. The relevant code defines a function to set an IPFS image hash, associating it with a timestamped event indicating the marriage image has been entered into the IPFS system. This function ensures only the owner can set the image hash.",
        "url": 734
    },
    {
        "nl_input": "The query requires a function to handle the finalization of funds, either by refunding investors if goals are not met or executing fund transfers if successful. It involves checking funding goals, enabling refunds when necessary, and ensuring proper crowd-sale finalization by transferring funds to the wallet or allowing refunds based on specific conditions.",
        "url": 735
    },
    {
        "nl_input": "The query requires a function that allows the owner to start or stop trading. It should be a single function capable of toggling the trading status based on a boolean input, ensuring only the owner can execute this action. The function must effectively manage a variable indicating whether trading is active or inactive.",
        "url": 736
    },
    {
        "nl_input": "The query requires functionality to tweak and update game-related parameters or contracts. Specifically, it needs logic to activate a game, update options such as game numbers or addresses, and potentially retrieve the total number of games. The provided code includes functions for activating games, updating game settings (e.g., boxMax), modifying contract addresses, and getting the total game count.",
        "url": 737
    },
    {
        "nl_input": "The query requires a function to buy outcome tokens from a market maker, specifying the token index, count, and maximum cost. It involves calculating costs, applying fees, transferring funds, and updating token sales records, ensuring the transaction adheres to market rules and constraints. The function must also emit an event for the purchase details.",
        "url": 738
    },
    {
        "nl_input": "The query requires an internal function for handling withdrawals during stage three, ensuring users can withdraw deposits and bonuses for specific dates after verification. It involves checking conditions like completion status and time buffers, updating user statuses, calculating withdrawal amounts including bonuses, and transferring funds to the user's address.",
        "url": 739
    },
    {
        "nl_input": "The query requires a mechanism to allow smart contracts (SCs) to upgrade themselves even after a lockdown. This involves enabling an upgrade function that transfers editing permissions to a new contract address while ensuring the original contract's lockdown status does not prevent upgrades. The solution should include an event notification for tracking upgrades.",
        "url": 740
    },
    {
        "nl_input": "The query requires a function to update the whitelist contract address. It needs a method that accepts a new contract address as input, validates it, and updates the whitelist with the new address while ensuring the address is not zero. The function should restrict access to authorized users, such as operators or owners.",
        "url": 741
    },
    {
        "nl_input": "The query requires a function to transfer tokens owned by the contract to another address. It needs parameters for the recipient address and the amount of tokens to transfer, ensuring the amount is positive and adjusting balances accordingly while emitting a transfer event.",
        "url": 742
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one address to another on behalf of a third party. It needs parameters for the sender's address, recipient's address, and the amount to transfer. The function should ensure the transaction amount does not exceed the approved allowance and update balances accordingly.",
        "url": 743
    },
    {
        "nl_input": "The query requires a function to calculate the number of tokens one can acquire based on the wei amount invested, considering a possible discount. It needs a uint256 input for the wei amount and another for the discount, returning a uint256 value representing the token quantity obtainable with the given investment and discount applied.",
        "url": 744
    },
    {
        "nl_input": "The query requires a function to retrieve the composition price of a specific token ID. It needs a method that accepts a token ID as input and returns the corresponding composition price as output, likely from a mapping or similar data structure within the contract. The solution should be publicly accessible and involve a view function for reading stored prices.",
        "url": 745
    },
    {
        "nl_input": "The query requires a function to enable trading for everyone. The most suitable code provides a function named `openTrading` that sets a boolean variable `tradingOpen` to true, allowing trading when called by an admin. Another option uses `startTrading` with a boolean parameter to start or stop trading, while the third involves a market-open modifier checking if trading is open for the public.",
        "url": 746
    },
    {
        "nl_input": "The query requires a function to confirm whether a document is a certification, which is a paid feature. The needed code should take an address and document identifier as inputs, check if the payment fee has been made, and return a boolean indicating the validity of the document as a certification for the given student.",
        "url": 747
    },
    {
        "nl_input": "The query requires enabling a pre-sale or sale feature in a contract. Specifically, it involves setting a condition to allow transfers during the sale phase or activating the sale status. The provided code examples demonstrate functions for checking pre-sale conditions, setting sale statuses for accounts, and returning the active sale state. The goal is to implement logic that activates or enables a sale feature based on specific criteria.",
        "url": 748
    },
    {
        "nl_input": "The query requires a function to refund ETH to destination addresses. It needs to ensure the sender is authorized, deduct the refund amount from the balance, and transfer the ETH to the specified address. The function should also handle multiple refunds if necessary, ensuring the lengths of address and value arrays match.",
        "url": 749
    },
    {
        "nl_input": "The query requires a function to change the state of a contract, such as releasing tokens, pausing ICO, or disabling whitelist. The provided code examples demonstrate modifying contract states: setting release states, pausing/unpausing ICOs, and enabling/disabling whitelist features, all typically restricted to the contract owner for security.",
        "url": 750
    },
    {
        "nl_input": "The query requires a function to return the number of signers associated with a specific function. It needs to identify signers based on a given input and provide a count of those signers from stored data. The solution should involve checking proposals or signer lists and returning the corresponding count efficiently.",
        "url": 751
    },
    {
        "nl_input": "The query requires a method to set or verify a token address within a smart contract. The provided code snippets demonstrate functions like `setToken` and `setTokenAddress`, which allow the contract founder to assign a token address, ensuring it is set only once and is non-zero. Additionally, there is a modifier to check if the token address is already set.",
        "url": 752
    },
    {
        "nl_input": "The query requires a function to purchase tokens from a reserve, ensuring the buyer is valid, sufficient tokens are available, and the transaction value is non-zero. It involves transferring funds, updating token balances for both the beneficiary and buyer, and emitting events to record the transaction details. The solution should handle token pricing and maintain accurate balance records.",
        "url": 753
    },
    {
        "nl_input": "The query requires a function to update statistics associated with a specific token ID. The most relevant code provides a function that updates the stats of a given token ID with new stats, ensuring the token is valid and the caller is authorized. It modifies the asset's stats property to the provided value.",
        "url": 754
    },
    {
        "nl_input": "The query requires a function to return the count of \"dicks,\" likely referring to a specific item or entry in a list or array named \"biggestDicks.\" The desired functionality should provide a simple uint return value representing the total number of these items stored. It focuses on counting elements, similar to other counting mechanisms in the provided code.",
        "url": 755
    },
    {
        "nl_input": "The query requires a function related to \"WorkOrder Emission,\" specifically for creating or handling work orders. The needed code should involve parameters such as `_marketorderIdx`, `_workerpool`, `_app`, `_dataset`, and `_params`, and perform operations like consuming market orders, locking costs, and emitting work orders while returning the work order address.",
        "url": 756
    },
    {
        "nl_input": "The query requires creating a Collateralized Debt Position (CDP) using all the Dai in the sender's balance (with prior approval), then generating and reinvesting Dai into the CDP until reaching the target liquidation price or minimum investment amount, ensuring trades are feasible.",
        "url": 757
    },
    {
        "nl_input": "The query requires overriding the _processPurchase function from Crowdsale to add purchased tokens to the beneficiary's balance. It involves calculating the token amount based on input and updating the depositedTokens mapping accordingly. The focus is on integrating this functionality within a smart contract context.",
        "url": 758
    },
    {
        "nl_input": "The query requires a function to calculate the fee charged on top of a value being sent. It should determine the fee based on the given value and return the calculated fee. The function must ensure that transfers below a certain threshold are fully covered by fees, with negligible values resulting in no fee.",
        "url": 759
    },
    {
        "nl_input": "The query requires a function to load the ETH balances of all accounts, returning an array of balances and the total balance. It involves iterating through a list of accounts, retrieving each account's balance, storing them in an array, and calculating the total balance of all accounts combined. The primary focus is on handling ETH balances specifically.",
        "url": 760
    },
    {
        "nl_input": "The query requires a function to check if the amount for a specific asset/currency has been approved in the Oversight address. It involves verifying approvals using the Oversight contract, ensuring that a given currency and amount pass validation. This is distinct from general approval functions that allow spending tokens on behalf of another user.",
        "url": 761
    },
    {
        "nl_input": "The query requires a function to allocate tokens to investors. Specifically, it needs a mechanism to mint or send tokens to investor addresses, potentially involving conditions or calculations based on invested amounts or predefined token values. The solution should ensure proper token allocation while adhering to defined rules or limits.",
        "url": 762
    },
    {
        "nl_input": "The query requires a function that processes a list of transfers, deconstructs combined input data (amount and receiving address), and optimizes gas usage by minimizing stored zeros on the blockchain. It involves checks for valid addresses, sufficient balances, and proper transfer execution while ensuring compatibility with contract and non-contract recipients.",
        "url": 763
    },
    {
        "nl_input": "The query requires a function to allocate tokens to specific addresses, potentially with additional parameters for tracking and ensuring proper allocation. The function should handle token distribution securely, possibly including checks for valid addresses and amounts, and may involve internal or external calls for token assignment. It could also include optional parameters like customer UUIDs and wei amounts for detailed tracking.",
        "url": 764
    },
    {
        "nl_input": "The query requires a function to approve a specific amount of tokens for transfer to another address. It involves specifying the address (_spender) that is allowed to transfer tokens and the amount (_value) approved for transfer. The function should ensure proper approval logic and emit an Approval event upon successful execution.",
        "url": 765
    },
    {
        "nl_input": "The query requires an event handler that processes the token received event, ensuring it is triggered when tokens are sent to the contract's address. It should include parameters for the token contract (_token), the sender's address (_from), and the value of tokens received (_value), with necessary validations to confirm the transaction's legitimacy.",
        "url": 766
    },
    {
        "nl_input": "The query requires a function allowing investors to latch Fci by themselves. The needed code should ensure that the process is only possible when specific conditions are met, such as the round being open, withdrawals not allowed, and the investor having a positive balance. It records the investor's stake in a specific round.",
        "url": 767
    },
    {
        "nl_input": "The query requires a function to remove an existing certificate authority, ensuring it cannot issue new certificates. The relevant code should include a function that deletes the certificate authority's entry and logs the removal action, effectively preventing further issuance of certificates by the specified authority.",
        "url": 768
    },
    {
        "nl_input": "The query requires a function to discard or reset stored values, akin to \"throwing away the stash.\" It should involve clearing balances, resetting states, or draining resources. The focus is on implementing a mechanism to eliminate stored data or funds, ensuring the system can be cleaned or emptied as needed.",
        "url": 769
    },
    {
        "nl_input": "The query requires a function to withdraw ether from a contract to a specified wallet. It needs to include parameters for the amount to withdraw, ensure sufficient balance, and transfer the specified amount to the designated wallet address while possibly restricting access to authorized users only.",
        "url": 770
    },
    {
        "nl_input": "The query requires a function that returns a boolean value indicating whether the sale is currently active. Specifically, it needs a straightforward check to determine if the sale status is active at the moment of invocation, without additional conditions or parameters.",
        "url": 771
    },
    {
        "nl_input": "The query requires a function to migrate token balances from the current contract to a new contract. It involves transferring balances, updating total supply, and interacting with a migration agent contract. The functionality should ensure proper validation, such as checking the migration agent address and balance constraints, and emit events to log migrations.",
        "url": 772
    },
    {
        "nl_input": "The query requires a function to withdraw funds from a contract, ensuring only authorized users (e.g., owner or admin) can initiate the transfer. It involves specifying the amount, checking if the contract balance is sufficient, transferring the funds to the caller's address, and optionally emitting an event to log the withdrawal.",
        "url": 773
    },
    {
        "nl_input": "The query requires a function to calculate the maximum number of extant nomins, which is the sum of the nomin pool and the total (circulating) supply. The result should be returned as a uint value using a specific function within a contract.",
        "url": 774
    },
    {
        "nl_input": "The query requires a function to be executed after the crowdsale ends, performing finalization tasks such as forwarding/refunding, transferring remaining tokens, or marking the crowdsale as finalized. It should ensure specific conditions are met, like checking if the sale has ended or goals have been reached, and may involve emitting events for refunds or finalization.",
        "url": 775
    },
    {
        "nl_input": "The query requires a function to set the pause status of NFTs, allowing an owner to toggle whether NFTs are paused or active. It involves a boolean parameter to update the pause state and may include an event emission to notify about the change in pause status.",
        "url": 776
    },
    {
        "nl_input": "The query requires a function to facilitate the selling of outcome tokens to a market maker, ensuring profit calculation, fee deduction, token transfer from seller to contract, and collateral transfer back to the seller, while maintaining sale records and emitting relevant events.",
        "url": 777
    },
    {
        "nl_input": "The query requires implementing a function for a free daily summon feature, ensuring users can summon a hero once per day with random ranks (common, rare, epic) based on probability. The code should track the last summon time for each user and enforce a one-day cooldown period between summons.",
        "url": 778
    },
    {
        "nl_input": "The query requires implementing a function to grant another address the right to transfer a specific monster using `transferFrom()`. This involves setting up approval for an address to spend tokens on behalf of another, ensuring proper allowance checks and balance updates during the transfer process.",
        "url": 779
    },
    {
        "nl_input": "The query requires a function to generate a unique key for a stock by combining the market and symbol. The key is created by concatenating the first six bytes of the market and symbol, resulting in a twelve-byte key. This ensures uniqueness for stock identification using both market and symbol information.",
        "url": 780
    },
    {
        "nl_input": "The query requires a function to handle refunds when KYC verification fails. It should withdraw ether from the participant, reclaim and burn associated tokens, update crowdsale metrics, blacklist the user to prevent further token purchases, and manage token distribution stages. The solution must involve precise calculations and secure transactions.",
        "url": 781
    },
    {
        "nl_input": "The query requires a modifier function that restricts the usage of certain contract functions to only the Etheraffle address. This ensures that specific functions can be executed exclusively by the designated Etheraffle address, providing a security measure to prevent unauthorized access. The modifier should include a require statement verifying the sender's address matches the Etheraffle address.",
        "url": 782
    },
    {
        "nl_input": "The query requires a function to set the arbitration fee per juror. It needs a parameter for the new fee amount and should only be executable by an authorized role (e.g., governor). The function updates the arbitrationFeePerJuror variable with the specified value.",
        "url": 783
    },
    {
        "nl_input": "The query requires modifying the DINRegistrar contract to update its address. Specifically, it needs a function that allows the owner to set a new registrar address, replacing the old one. This involves ensuring only the authorized entity can perform this action and emitting an event to notify about the change.",
        "url": 784
    },
    {
        "nl_input": "The query requires a function to batch transfer tokens from the owner's balance to multiple addresses. It needs to accept an array of addresses and corresponding token amounts, ensure the arrays' lengths match, limit the number of addresses, and execute individual transfers in a loop, finally confirming the operation's success.",
        "url": 785
    },
    {
        "nl_input": "The query requires enabling the TeamWithdraw state in a smart contract. Specifically, it involves transitioning the contract's state to TeamWithdraw, initializing a budget plan with details like proposal ID, budget amount, start time, and end time, while ensuring the contract is in the correct initial state (NotReady) before enabling TeamWithdraw.",
        "url": 786
    },
    {
        "nl_input": "The query requires a function to set initial shareholders in a contract, ensuring each shareholder is uniquely added and the total count of shareholders is updated accordingly. The function should validate that new shareholders are not already set and are not the owner address, while also handling the addition of shareholders within predefined limits.",
        "url": 787
    },
    {
        "nl_input": "The query requires a function to modify gift properties, including price, description, and URL, with the condition that the gift must exist. The relevant code allows updating these properties for a specific gift ID, ensuring only the owner can perform this action. It updates the gift's price, description, and link in storage. Other provided codes are unrelated to gift property changes.",
        "url": 788
    },
    {
        "nl_input": "The query requires a function to calculate investors' locked token amounts released in three batches over time. It needs to check the current time against predefined release dates and return the appropriate locked amount based on the batch schedule, reducing the locked amount as each batch is released.",
        "url": 789
    },
    {
        "nl_input": "The query requires a function to reset a bag's level to 0 if it hasn't been purchased within a specified timeout period, while keeping the existing owner unchanged. The solution should involve checking the time elapsed since the last purchase and resetting the level accordingly without altering ownership.",
        "url": 790
    },
    {
        "nl_input": "The query requires a function to make an investment based on a pricing strategy, determining token amounts for the receiver. It involves calculating token quantities using the pricing strategy and optionally tracking payments via a customer ID. The result should specify the number of tokens bought.",
        "url": 791
    },
    {
        "nl_input": "The query requires a function to handle both locked and unlocked tokens. Specifically, it needs functionality to issue unlocked tokens to a specified address with a given value and the ability to move locked tokens to a team account after a release time or unlock vested tokens by calculating the transferable amount based on vesting conditions.",
        "url": 792
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to set a specific time duration after which a price is considered stale. This ensures that outdated prices are not used, maintaining data freshness and reliability in transactions or pricing mechanisms. The function should be accessible only to the owner for security and integrity purposes.",
        "url": 793
    },
    {
        "nl_input": "The query requires a function that, when called by the authorized owner or manager, unpauses the smart contract and returns it to its normal operational state. This involves setting a 'paused' variable to false and may include emitting an event to signal the unpause action.",
        "url": 794
    },
    {
        "nl_input": "The query requires a modifier or function ensuring token purchases occur only between predefined start and end dates. It checks the current time against these dates to allow transactions exclusively within the specified sale period, preventing early or late purchases. Additionally, it may include conditions for available tokens and price calculations based on the number of tokens sold.",
        "url": 795
    },
    {
        "nl_input": "The query requires a function to buy tokens during a presale. It needs to handle token calculation based on input value, ensure the sale is within a specified time frame, verify token availability, and update balances accordingly. Additionally, it should manage pricing tiers, record total tokens sold, and transfer any excess funds back to the buyer.",
        "url": 796
    },
    {
        "nl_input": "The query requires a function allowing participants to withdraw funds if the pre-sale does not meet the minimum funding level. The function should check if the pre-sale period has ended, verify if the minimum funding is not reached, ensure the participant's balance is sufficient, update balances, and send the funds back to the participant.",
        "url": 797
    },
    {
        "nl_input": "The query requires a function to claim all vested tokens up to the current date on behalf of a user. It needs to calculate vested tokens based on elapsed time and transfer them to a specified address, ensuring proper authorization and ownership checks are in place for security and correct execution.",
        "url": 798
    },
    {
        "nl_input": "The query requires a function that allows the owner/minter/creator of a contract to mint new coins. The function should ensure only the authorized sender can execute it, typically through modifiers like `onlyOwner` or similar checks, and update the total supply and balance accordingly.",
        "url": 799
    },
    {
        "nl_input": "The query requires a function to determine if the crowdsale has started by checking if the current block number is greater than or equal to the start block. It seeks a simple boolean return indicating whether the start condition has been met, focusing on the block number as the determining factor for the crowdsale's initiation.",
        "url": 800
    },
    {
        "nl_input": "The query requires a function to validate a transcoding options string by ensuring its length is a multiple of VIDEO_PROFILE_SIZE and greater than zero. It involves checking the string's composition based on video profile IDs and confirming its structural validity according to predefined size constraints.",
        "url": 801
    },
    {
        "nl_input": "The query requires a function that sets the points of all tokens between the last chunk set and a specified amount, using previously collected data to calculate points for each token and updating mappings accordingly. It involves iterating through tokens, calculating points, and managing worst-performing tokens within limits.",
        "url": 802
    },
    {
        "nl_input": "The query requires a function to remove received foreign tokens from a contract. Specifically, it needs a function that takes the address of the foreign token as a parameter, ensures the address is valid, removes the token from the contract's records, and emits an event indicating the removal of the token.",
        "url": 803
    },
    {
        "nl_input": "The query requires a function to allow specific addresses to participate early in a process. It needs to set a whitelist for early participants, defining their status and funding caps, ensuring valid addresses and appropriate timing. The function should handle both new and existing addresses in the whitelist.",
        "url": 804
    },
    {
        "nl_input": "The query requires a function to add a wallet to additional bonus members, accessible only by the contract owner. The function should activate the bonus state for the specified wallet, ensuring it is included in the additional bonus member list. This involves managing wallet states and ensuring proper authorization for the operation.",
        "url": 805
    },
    {
        "nl_input": "The query requires creating an auction for a specific deed, involving parameters like deed ID, start price, end price, and auction duration. The solution should ensure the caller is authorized (deed owner or contract) and validate input constraints. It must escrow the deed and initialize an auction structure with owner, price range, duration, and start time before creating the auction.",
        "url": 806
    },
    {
        "nl_input": "The query requires a function to add a holder to the holders list, ensuring the holder is not already present. The function should manage a list of holders and assign a unique number to each holder based on their position in the list. This involves checking if the holder exists before adding them and updating the holder's number accordingly.",
        "url": 807
    },
    {
        "nl_input": "The query requires a function to check if an asset exists by verifying whether its owner is not zero. The relevant code provides a function named `isCreated`, which takes a bytes32 symbol as input and returns a boolean indicating the existence of the asset based on its owner's address. This function meets the requirement for checking asset existence.",
        "url": 808
    },
    {
        "nl_input": "The query requires a function to withdraw ether from a contract. It should include the functionality to transfer a specified amount of ether to one or multiple addresses, ensuring the contract balance is sufficient. Optionally, it may divide the withdrawn amount among different addresses or transfer the entire balance to the owner. Access should be restricted to the contract owner.",
        "url": 809
    },
    {
        "nl_input": "The query requires a function to check if a pet is on a sponsored leaderboard, ensuring each pet can only be on one at a time. The relevant code provides a boolean function `petOnLeaderboards(uint64 petID)` that returns whether a pet with a specific ID is currently on any leaderboard. Other codes are unrelated to this requirement.",
        "url": 810
    },
    {
        "nl_input": "The query requires extracting transfer configurations, including base, rate, collector, no_transfer_fee status, and minimum_transfer_amount from a token storage function. It focuses on reading these settings rather than enabling or controlling transfers. The description should highlight the function's ability to retrieve and return these specific transfer-related parameters.",
        "url": 811
    },
    {
        "nl_input": "The query requires a function for service transfer of tokens, allowed exclusively when called by authorized masters. It should handle token transfers between specified addresses with a return confirmation. The function must ensure security and permission constraints, allowing execution only from approved master entities.",
        "url": 812
    },
    {
        "nl_input": "The query requires a function to withdraw the house stake, ensuring the remaining stake meets the minimum requirement and covers potential losses. It involves transferring the specified value to the owner while maintaining contract balance constraints.",
        "url": 813
    },
    {
        "nl_input": "The query requires a function to transition to the next phase by setting start time, end time, and token cap for the upcoming phase, then designating it as the current phase. It involves managing round IDs, updating timestamps, calculating token caps based on remaining tokens, and emitting an event upon successful transition.",
        "url": 814
    },
    {
        "nl_input": "The query requires a function to change the stage of a crowdsale, allowing the owner to set it to either PreICO or ICO by providing a corresponding value. The function ensures only the owner can make this change and updates the crowdsale stage accordingly.",
        "url": 815
    },
    {
        "nl_input": "The query requires a function that validates parameters, returning true if they meet specific conditions. It involves checking the validity of input parameters, such as ensuring arrays have matching lengths, maintaining order in array values, or confirming a parameter falls within defined limits. The focus is on parameter integrity and correctness.",
        "url": 816
    },
    {
        "nl_input": "The query requires a function within a smart contract that allows the contract owner to transfer ownership of any top-level domain managed by the contract to a specified address. This involves a function with parameters for identifying the domain and setting its new owner, restricted to execution by the current owner.",
        "url": 817
    },
    {
        "nl_input": "The query requires a function allowing wineries to record operations externally. It needs parameters such as track ID, operation ID, operation code, date, area code, and ICQRF code. The function should verify winery permissions, store the operation details, and emit a log upon successful addition.",
        "url": 818
    },
    {
        "nl_input": "The query requires modifying the code to ensure that any missed payday's owed pay is carried over to the next pay period. This involves adjusting the logic to accumulate unpaid amounts and include them in future payments, rather than discarding or resetting them. The current implementation only pays based on the latest salary calculation without considering past owed amounts.",
        "url": 819
    },
    {
        "nl_input": "The query requires a function allowing users to sell tokens for ETH, ensuring the contract has an approved allowance before execution. The code should handle token transfer from the user to the contract and send equivalent ETH to the user based on a predefined rate or price, with proper error handling and event updates.",
        "url": 820
    },
    {
        "nl_input": "The query requires a function that calculates and returns the number of tokens based on a given rate. Specifically, it needs a mechanism to determine token amounts corresponding to input values according to predefined rates. The focus is on functions like `getRate` or `getTokenAmount`, which compute token quantities using rate-related logic.",
        "url": 821
    },
    {
        "nl_input": "The query requires a function to subtract two numbers, reverting on overflow if the subtrahend is greater than the minuend. It ensures safe mathematical operations by validating that the second number does not exceed the first before performing subtraction, thereby maintaining data integrity and preventing unexpected results.",
        "url": 822
    },
    {
        "nl_input": "The query requires a function to permanently lock the maximum supply to its current value. The desired functionality involves setting a boolean flag (isMaxSupplyLocked) to true, ensuring the maxSupply cannot be altered thereafter, and potentially emitting an event to notify about the locking action.",
        "url": 823
    },
    {
        "nl_input": "The query requires a function to handle the claiming of IBC tokens, ensuring that the claim is valid based on the sale stage and user balance. It should distribute tokens, apply prediction bonuses if eligible, and update balances accordingly. The solution must involve checking conditions, calculating bonuses, updating states, and transferring tokens to the claimant.",
        "url": 824
    },
    {
        "nl_input": "The query requires a function to create or activate a special manager, ensuring the address is valid and not already active. It involves mapping addresses, checking activation status, and updating records accordingly, with events or return values confirming success or failure. The focus is on managing special manager statuses within a smart contract system.",
        "url": 825
    },
    {
        "nl_input": "The query requires an initialization function that should be called after contract deployment. This function ensures the contract is properly set up by finalizing specific parameters, often restricting initialization to one call and verifying the caller's authorization. It may involve setting initial values for variables or confirming the contract's readiness for operation.",
        "url": 826
    },
    {
        "nl_input": "The query requires a function to send tokens to a specified address with a defined amount. The function should ensure the sender is authorized, the amount does not exceed the available deposit, and the token transfer is successful while updating the remaining deposit. This involves external calls and state updates within the contract.",
        "url": 827
    },
    {
        "nl_input": "The query requires a function to determine if the calldata specifications of two orders can match. It involves comparing buy and sell order calldata, applying replacement patterns if specified, and returning a boolean result indicating whether the calldata can be matched after adjustments.",
        "url": 828
    },
    {
        "nl_input": "The query requires a function that allows the current owner of a contract to transfer ownership to a new address. The function should ensure only the current owner can initiate this transfer and must validate that the new owner's address is not null. It may also include an event to log the transfer of ownership for transparency.",
        "url": 829
    },
    {
        "nl_input": "The query requires a function to return the balance of a specific account, given the account's address. It needs parameters for the account address and should return the corresponding balance value. The function is intended to be publicly accessible and should not modify the contract state, indicated by the 'view' or 'constant' keyword.",
        "url": 830
    },
    {
        "nl_input": "The query requires a function to pay unpaid dividends to investors. It should handle dividend distribution, ensure the sender is eligible, and update the dividend status accordingly. The function must also include necessary checks, such as confirming nonzero values and maintaining accurate accounting of dividend shares and funds.",
        "url": 831
    },
    {
        "nl_input": "The query requires a function to calculate the user's share percentage on a specified date. It involves determining the period index, calculating BMC days for the user, and computing the total BMC deposit. The result is the user's share percentage based on these values, ensuring accurate retrieval of shares in percents for the given date.",
        "url": 832
    },
    {
        "nl_input": "The query requires a function to check if a user has already purchased Ether, returning the contribution amount associated with the user's address. This involves identifying a contract with a mapping or storage structure that tracks user contributions in Ether, allowing retrieval of this information via a public view function. The focus is on debugging and compatibility with online Solidity tools like Remix.",
        "url": 833
    },
    {
        "nl_input": "The query requires a modifier to restrict function calls to only the exchange contract. This ensures that specific functions can only be executed by the designated exchange contract, using a require statement to validate the caller's address against the predefined exchange address.",
        "url": 834
    },
    {
        "nl_input": "The query requires a function to unlock vested tokens and transfer them to the grantee. It involves calculating the vested tokens, determining the transferable amount, updating the transferred balance, reducing the total vesting, and finally transferring the tokens to the grantee's address while emitting an event for the transaction.",
        "url": 835
    },
    {
        "nl_input": "The query requires a function to calculate the average of two signed integers, rounding 1.5 towards zero. The needed code should include a function that sums two integers, checks for overflow conditions, and divides the result by two, ensuring proper handling of positive and negative numbers while adhering to the specified rounding behavior.",
        "url": 836
    },
    {
        "nl_input": "The query requires a function to withdraw ether from a contract, specifying the amount in wei to be withdrawn. The function should ensure only the owner can initiate the withdrawal and may involve transferring funds to specific addresses or the owner's address while checking the contract's balance.",
        "url": 837
    },
    {
        "nl_input": "The query requires a function to retrieve a contract's address by providing its name as a parameter. The function should check if the contract exists and return its address if it does. This involves mapping contract names to their addresses and ensuring the requested contract name is valid and associated with an address.",
        "url": 838
    },
    {
        "nl_input": "The query requires a function to manage internal balances within a contract, including setting or creating token balances. Specifically, it needs functionality to assign a balance to an address (e.g., `_holder`) or initialize balances during contract execution. The provided code demonstrates internal functions for setting balances and creating tokens, meeting these requirements.",
        "url": 839
    },
    {
        "nl_input": "The query requires a function to transfer ownership of an SSP record. Specifically, it needs a method that accepts the record's key and the new owner's address, then transfers the ownership accordingly. The function should ensure proper authorization and validation before executing the transfer.",
        "url": 840
    },
    {
        "nl_input": "The query requires a function to drain Ether from a contract. It needs a method that allows the owner to specify an amount and transfer it to their address, ensuring security and proper functionality. The focus is on implementing a safe and effective way to withdraw funds, typically restricted to the contract owner.",
        "url": 841
    },
    {
        "nl_input": "The query requires a function to issue tokens based on Ether received. The function should check the validity of the sender, calculate the number of tokens corresponding to the Ether received according to a specific rate, update the token balance, and transfer the received Ether to a designated wallet.",
        "url": 842
    },
    {
        "nl_input": "The query requires a function to append a uint value (in decimal format) to a string. It needs to handle the conversion of the uint into its decimal representation and concatenate it to the given string, returning the final concatenated string as the output.",
        "url": 843
    },
    {
        "nl_input": "The query requires a method to distribute tokens proportionally to contributors after the contribution period ends. The method should ensure only the owner can call it, verify the period has ended, calculate each contributor's share based on their contribution, mark contributors as compensated, and transfer the proportional tokens to them.",
        "url": 844
    },
    {
        "nl_input": "The query requires a function to remove a specific privilege or role (e.g., \"destroyer\") from an address when it is no longer needed. The solution should include a mechanism to revoke the privilege, update related lists, and log the removal for tracking purposes.",
        "url": 845
    },
    {
        "nl_input": "The query requires a function allowing an account to place a higher bid on a token. It needs to ensure the new bid exceeds existing bids, update the highest bidder and bid value, and handle refunds for previous bidders if applicable. The solution should also emit an event confirming the bid increase.",
        "url": 846
    },
    {
        "nl_input": "The query requires a function to retrieve the balance of a token named \"Faucet.\" Specifically, it needs a method that can return the balance associated with the Faucet token address. The most relevant code should interact with the ERC20 token interface and use the `balanceOf` function to obtain the balance for the given contract or address.",
        "url": 847
    },
    {
        "nl_input": "The query requires a function to set the price for the EXH Token, ensuring the price is non-zero and can only be executed by the owner. The function should update the token price and possibly trigger a state change notification.",
        "url": 848
    },
    {
        "nl_input": "The query requires a function to calculate the TOTAL payout per tier using the odds method, taking the number of winners and the matches index as parameters. It multiplies the single odds payout by the number of winners to determine the total payout for a specific tier.",
        "url": 849
    },
    {
        "nl_input": "The query requires a function to withdraw a specified amount of ether from a contract to the owner's address, ensuring the contract balance is sufficient before transferring. The function should restrict access to the owner only and may include event logging or additional parameters for enhanced functionality.",
        "url": 850
    },
    {
        "nl_input": "The query requires creating an original artwork using a given genome. The code should allow a caller to generate a unique artwork by providing a specific genome, ensuring the artwork's originality and associating it with an owner. It may involve checks for ownership, limits on artwork creation, and payment conditions.",
        "url": 851
    },
    {
        "nl_input": "The query requires a function to transfer tokens between addresses. It involves adjusting token balances for the sender and receiver, ensuring proper authorization, and confirming successful execution. The function may include parameters like sender, receiver, token address, and amount, with potential additional checks or modifiers for security and ownership validation.",
        "url": 852
    },
    {
        "nl_input": "The query requires a function that calculates the index in a one-dimensional array based on two-dimensional coordinates (_x, _y) and ensures the coordinates are within bounds. If either coordinate is out of bounds, an exception should be thrown. The function should return the calculated index using the formula: _x * size + _y.",
        "url": 853
    },
    {
        "nl_input": "The query requires a function to slice 20 contiguous bytes from a byte array, starting at a specified position. The function should take the byte array and starting index as inputs and return a 20-byte slice. This involves iterating through the specified range of the array and extracting the relevant bytes to form the output.",
        "url": 854
    },
    {
        "nl_input": "The query requires a function modifier to verify if `msg.sender` matches a specific contract address resolved by a `ContractResolver`. The modifier should ensure that the sender is authorized by comparing it with the resolved contract address, allowing execution only if the condition is met. This ensures access control based on contract resolution.",
        "url": 855
    },
    {
        "nl_input": "The query requires a function to return an array containing the count of different weapons in an army, specifically drones, planes, helicopters, and tanks, associated with a given army ID. The result should provide a consolidated view of the army's weapon inventory in a structured format.",
        "url": 856
    },
    {
        "nl_input": "The query requires a function to set the PriceSetter address, allowing it to define a token price in wei. The solution should include a function named 'setPriceSetter', accepting an address parameter and ensuring only authorized users can modify it, as demonstrated in the provided code examples. This ensures controlled access for price setting.",
        "url": 857
    },
    {
        "nl_input": "The query requires a function to withdraw tokens with specific conditions: it should allow token withdrawal after certain criteria are met (e.g., crowdsale ends), ensure the sender has sufficient balance, and transfer the specified amount to the recipient. Some versions include access restrictions (e.g., onlyAdmin or onlyOwner).",
        "url": 858
    },
    {
        "nl_input": "The query requires a function to prevent users from submitting duplicate bets by checking if the same bet (with identical match ID and betting price) has already been placed by the user. The solution involves iterating through the user's betting history to ensure uniqueness in submitted bets.",
        "url": 859
    },
    {
        "nl_input": "The query requires a function to safely multiply two unsigned integers (x and y), ensuring no overflow occurs. If an overflow is detected, an exception should be thrown. The function should return the product of x and y if the operation is successful.",
        "url": 860
    },
    {
        "nl_input": "The query requires a description of a modifier function that executes before the main function, ensuring specific conditions are met. It should restrict function execution based on predefined criteria, such as only allowing execution by a specific address, contract owner, or when the contract is not paused. The modifier must integrate seamlessly with the contract's logic.",
        "url": 861
    },
    {
        "nl_input": "The query requires a function to check if an angel is on a sponsored leaderboard, ensuring each angel can only be on one at a time. The relevant code should return a boolean value indicating the angel's presence on the leaderboard using their unique ID. Other unrelated functionalities, such as pet leaderboards or game management, should be ignored.",
        "url": 862
    },
    {
        "nl_input": "The query requires a function to determine the maximum available amount of an order that can be executed, considering factors like the order's taker token amount, filled amounts, and balance in the vault. It involves calculations using subtraction, multiplication, and division while ensuring the minimum value is returned for safe execution.",
        "url": 863
    },
    {
        "nl_input": "The query requires a function to withdraw funds, splitting the specified amount equally among all contract owners. It ensures permissible withdrawal conditions are met, calculates the individual share using SafeMath division, and transfers the funds to each owner. The primary focus is on equitable distribution and secure transactions among multiple owners.",
        "url": 864
    },
    {
        "nl_input": "The query requires a function that transfers tokens from one address to another, ensuring any errors throw exceptions instead of returning false to minimize user errors. It should include standard checks and throw if transfers are disabled. The function must return true upon successful transfer.",
        "url": 865
    },
    {
        "nl_input": "The query requires a function to set or change the minimum amount of Wei needed for a transaction, ensuring it is greater than 0 and divisible by 10. It should emit an event upon successful change and only be executable by the contract owner. The default minimum Wei amount is 1000.",
        "url": 866
    },
    {
        "nl_input": "The query requires a function to retrieve the current round, applicable in specific contexts. It needs to return an address representing the current round. The focus is on identifying a method that determines the current round by checking conditions or using predefined logic within the contract structure.",
        "url": 867
    },
    {
        "nl_input": "The query requires a function to publish an article with a unique hash, associate it with a key hash, and allocate tokens, while enforcing constraints on the number of tokens, time between publications, and uniqueness of the article hash. The function should also update publication records and emit a result upon completion.",
        "url": 868
    },
    {
        "nl_input": "The query requires a function that allows the owner to enable token transfers. It should set a boolean value to true, indicating that transfers are enabled, without necessarily involving additional operations like burning tokens or changing ownership. The focus is on providing the owner the ability to activate transfer functionality simply.",
        "url": 869
    },
    {
        "nl_input": "The query requires a function to successfully remove an admin address, returning true upon successful removal. It involves checking if the admin exists, ensuring the sender is not the admin being removed, and deleting the admin's status while maintaining the integrity of the admin list. The focus is on securely removing an admin and confirming the operation's success.",
        "url": 870
    },
    {
        "nl_input": "The query requires a function that enables the pendingAdmin address to complete the admin change process. This involves verifying the pendingAdmin, updating the admin address, and resetting the pendingAdmin to zero. The solution should ensure proper authorization and accurate address updates to finalize the transition securely.",
        "url": 871
    },
    {
        "nl_input": "The query requires a mechanism to validate token transfer destinations, ensuring they are not zero addresses, the contract's own address, or specific restricted addresses like owner, admin, or token sale addresses. The solution should involve a modifier or function that enforces these checks before allowing token transfers.",
        "url": 872
    },
    {
        "nl_input": "The query requires a function to update the status of a minting agent. The desired function should accept an address and a boolean status as parameters, allowing the owner to modify the minting agent's authorization status. This ensures flexibility in managing which addresses are permitted to perform minting operations.",
        "url": 873
    },
    {
        "nl_input": "The query requires a function to return the total number of tokens available for purchase at the current moment. This involves checking the existing supply and ensuring that the sale is active. The result should reflect the remaining tokens that can still be bought by users within the defined limits and time frame.",
        "url": 874
    },
    {
        "nl_input": "The query requires a function that allows an administrator to finalize ownership changes after a predefined period, ensuring the transfer is valid within specific blocks or time constraints. It involves verifying the pending owner or admin, updating the ownership, and resetting related variables to complete the transition securely.",
        "url": 875
    },
    {
        "nl_input": "The query requires a function to stake a certain amount of tokens on behalf of a user, transferring the specified amount from the caller's account. It must also trigger a 'Staked' event and allow optional data inclusion. The function should handle stakes of at least 1 token and potentially reward the user with credits.",
        "url": 876
    },
    {
        "nl_input": "The query requires a function to execute a bid on an auction. Specifically, it needs a payable function that ensures the bid is placed before the auction ends and that the new bid exceeds the current highest bid. Upon a successful bid, the function should update the highest bidder and bid amount, and emit an event indicating the increased bid.",
        "url": 877
    },
    {
        "nl_input": "The query requires a function to approve a specified amount of tokens for spending by a designated address on behalf of the message sender. This involves setting an allowance for the spender address, ensuring they can only spend up to the approved amount, and confirming the approval through a return value or event.",
        "url": 878
    },
    {
        "nl_input": "The query requires a function that allows the owner to update the token rate. It should be a simple implementation where the owner can modify the rate of tokens, typically in response to certain conditions or manually set a new rate, ensuring flexibility in managing token economics within a smart contract.",
        "url": 879
    },
    {
        "nl_input": "The query requires a function to throw an exception when two amounts are not equal. The description involves comparing two values (expected and actual) and triggering an exception (e.g., revert()) if they differ. This ensures strict equality between the provided amounts, halting execution if the condition is not met.",
        "url": 880
    },
    {
        "nl_input": "The query requires creating a new proxy contract, assigning an owner, and setting a recovery key. The relevant code should include functionality to initialize a proxy contract, accept parameters for the owner and recovery key, and log or confirm the creation event. Only the code snippet from 'url': 881 fully matches this requirement.",
        "url": 881
    },
    {
        "nl_input": "The query requires a function that handles potential contract jamming by skipping problematic addresses, allowing the contract to continue operating. It should also permit the skipped address to appeal and revert the skip if malicious activity caused it. This ensures contract functionality is preserved while providing recourse for unjust skips.",
        "url": 882
    },
    {
        "nl_input": "The query requires a function to change the successor address in a smart contract, ensuring the new successor is not a zero address. The most relevant code provides a `setSuccessor` function that fulfills this requirement by allowing an admin to update the successor address after validating it is not null.",
        "url": 883
    },
    {
        "nl_input": "The query seeks to determine the profit amount. The relevant code provides functions for calculating profit share, token emission based on investment value and discount, and ETH rewards for selling tokens. Specifically, it involves retrieving a user's profit share, determining token quantity based on investment, and calculating rewards from token sales. The focus is on financial computations within smart contracts.",
        "url": 884
    },
    {
        "nl_input": "The query requires a function to check if a customer's transaction of payment for MCW has been spent. It needs to take the transaction ID as input and return a boolean value indicating whether the transaction has been spent based on the timestamp record in the transaction registry.",
        "url": 885
    },
    {
        "nl_input": "The query requires a function that sets the free memory pointer to a position beyond all accessed memory. This involves using inline assembly to store the current memory size at the specific memory location (0x40), effectively updating the free memory pointer in Solidity. The described functionality is essential for low-level memory management in smart contracts.",
        "url": 886
    },
    {
        "nl_input": "The query requires a function to quickly check if Round1 is active, allowing only one execution. The relevant code should provide a mechanism to verify the current round, ensuring it specifically identifies Round1 and limits the check to a single occurrence. This involves comparing the current state against predefined round conditions and constraints.",
        "url": 887
    },
    {
        "nl_input": "The query requires a function to remove an address from a whitelist. Specifically, it needs a function that takes an address as input and removes it from the whitelist by setting its status to false, ensuring only the owner can perform this action. The provided code examples include functions for removing addresses from lists, with one directly matching the requirement to remove an address from a whitelist.",
        "url": 888
    },
    {
        "nl_input": "The query requires a function to handle an expensive combat process, ensuring sufficient gas is provided. It needs a mechanism to manage gas costs and potentially skip or appeal actions to prevent contract jams. The solution should address gas expenses in transactions and provide a fallback for insufficient funds, maintaining contract functionality and fairness.",
        "url": 889
    },
    {
        "nl_input": "The query requires a function to withdraw the balance and share pot. Specifically, it involves transferring ETH and token balances to a player under certain conditions, such as game completion or specific token values. The function must handle calculations for shares, fees, and ensure proper balance updates while interacting with player data.",
        "url": 890
    },
    {
        "nl_input": "The query requires a function to handle air delivery transactions using counts instead of wei amounts in the BioX system. It involves transferring tokens from the owner's balance to another address, adjusting the amount based on supply conditions, and emitting a transfer event. The focus is on token balance management and ensuring the correct amount is transferred.",
        "url": 891
    },
    {
        "nl_input": "The query requires a function that allows qualified crowdsale partners to purchase Star Tokens. It involves verifying the partner's qualification, calculating token amounts based on contributed value, ensuring caps are not exceeded, and optionally handling commission fees. The focus is on enabling token purchases specifically for qualified partners in a crowdsale context.",
        "url": 892
    },
    {
        "nl_input": "The query requires a modifier ensuring only the owner can execute a function. It enforces access control by verifying if the caller (msg.sender) is the owner, restricting execution to authorized owners only. This protects critical functions from unauthorized access.",
        "url": 893
    },
    {
        "nl_input": "The query requires a function to check the size of an ERC223 contract, ensuring it is nonzero to confirm it as a contract. The provided codes do not directly meet this requirement, as they focus on token balance checks rather than contract size verification. A suitable function should retrieve the contract's code size and verify it is greater than zero.",
        "url": 894
    },
    {
        "nl_input": "The query requires a function to calculate compound interest output based on input amount and number of payouts, considering interest rate and exit tax. It needs to iteratively compute the output by applying the interest rate for each payout and adjusting for any applicable taxes, ensuring accurate compounding interest calculations.",
        "url": 895
    },
    {
        "nl_input": "The query requires computing all second-round winners from the first-round winners, considering hero power and randomness. It involves comparing hero powers of paired first-round winners and determining second-round winners based on conditional logic involving random numbers. The task focuses on processing and selecting winners through specific comparisons and probability conditions.",
        "url": 896
    },
    {
        "nl_input": "The query requires a function to check if the current round is within its lock period. Specifically, it calculates the lock period based on the round length and determines whether the current block number falls within this locked phase of the round by comparing it with the starting block of the round and the locked blocks count.",
        "url": 897
    },
    {
        "nl_input": "The query requires a function that resets a purchaser's cap limit when the specified window duration is met. It should take the purchaser's address and the amount of tokens purchased as parameters, checking if the time window has elapsed, and either reset or update the purchase record accordingly.",
        "url": 898
    },
    {
        "nl_input": "The query requires a function to set a global activation fee, ensuring the new fee is greater than zero and different from the current fee. It should also emit an event notifying of the update and return a boolean indicating success. The function must be accessible only to authorized users (e.g., owner).",
        "url": 899
    },
    {
        "nl_input": "The query requires a function to set prices within a smart contract, allowing the owner to update selling and buying prices or a single price for a token. The provided codes demonstrate variations of such functionality, including setting sell and buy prices, appointing a PriceSetter role, or updating a single token price while ensuring the owner's authority.",
        "url": 900
    },
    {
        "nl_input": "The query requires a function that allows the contract owner to transfer any trapped ETH within the contract to an external address, typically the owner's address. The function should ensure only the authorized owner can initiate the transfer of the entire contract balance.",
        "url": 901
    },
    {
        "nl_input": "The query requires a function to check if a gift exists and has not been redeemed, returning true only when both conditions are satisfied. It involves verifying the existence of a gift and ensuring it is not marked as redeemed in the system. This logic ensures valid gifts can be identified accurately before further processing.",
        "url": 902
    },
    {
        "nl_input": "The query requires a function to handle Ether (ETH) deposits or rewards in a contract. Specifically, it needs functionality to either deposit ETH for transaction fees after successful contract completion or add ETH rewards to a contract. The solution should ensure proper handling of payable functions and include necessary conditions or modifiers for security.",
        "url": 903
    },
    {
        "nl_input": "The query requires a function to approximate \"e^x\" using Maclauren summation with upshifted accuracy, generated by 'PrintFunctionFixedExpUnsafe.py'. It needs to handle large computations while ensuring precision and preventing overflow, incorporating safe multiplication and addition methods for accurate results in complex calculations.",
        "url": 904
    },
    {
        "nl_input": "The query requires identifying code that allows adding a new member to a bonus system, restricted to contract owner execution. The relevant code should include functionality to add a wallet address to a bonus member list with an active state, ensuring only the contract owner can perform this action.",
        "url": 905
    },
    {
        "nl_input": "The query requires creating a new tank type with specified attributes: starting price, earnings, base health, attack, armor, and speed. The implementation should involve adding these attributes to a data structure, likely an array or mapping, and incrementing a type identifier to track newly created tank types. Only relevant code from the provided snippets should be considered for this task.",
        "url": 906
    },
    {
        "nl_input": "The query requires a function to determine the current state or stage based on the timestamp. It involves checking specific date ranges and active states for different phases (e.g., PrivateSale, PreSale, CrowdSalePhase1-3) and returning the corresponding state. If no conditions are met, it returns a default state (Gap). The function uses conditional statements to compare the current timestamp with predefined dates.",
        "url": 907
    },
    {
        "nl_input": "The query requires a function that allows the current owner of a contract to transfer ownership to a new Ethereum address. The function should ensure the new owner address is valid (not zero) and update the owner attribute accordingly, potentially emitting an event to confirm the transfer. Only the current owner can invoke this function.",
        "url": 908
    },
    {
        "nl_input": "The query requires a function to initiate a game, validating the arbiter, ensuring correct player count, and managing game states like allocation, activation, and pot initialization. It also involves handling edge cases such as arbiter locks or invalid inputs, while updating game metadata like active status, timestamps, and player information.",
        "url": 909
    },
    {
        "nl_input": "The query requires implementing a modifier that restricts function access based on the `msg.sender` attribute. It ensures that only specific entities, such as a predefined owner, payer, or resolved contract address, can execute certain functions. The modifier uses a `require` statement to validate `msg.sender` against authorized addresses or mappings before proceeding.",
        "url": 910
    },
    {
        "nl_input": "The query requires setting addresses for vested team tokens distribution upon finalization. Specifically, it needs a function to define the addresses for team and advisor allocation contracts, as well as ICO contributors, ensuring neither address is zero. This setup ensures proper token allocation post-crowdsale.",
        "url": 911
    },
    {
        "nl_input": "The query requires a function to sell eggs in exchange for Ether (ETH), deducting a fee and transferring the remaining value to the user. It involves calculating egg value, applying fees, updating user balances, and ensuring proper transfers. The provided code snippets include logic for selling items, handling fees, and transferring funds, which align with these requirements.",
        "url": 912
    },
    {
        "nl_input": "The query requires a function that allows the admin to toggle prebridge states. Specifically, it needs a mechanism within a smart contract where the admin has the authority to switch the prebridge state between true and false, typically using a modifier like onlyOwner to restrict access to authorized users.",
        "url": 913
    },
    {
        "nl_input": "The query requires extracting invested Ethereum from the Pre-ICO phase. It needs a function that transfers the accumulated Ethereum investments during the Pre-ICO to the contract owner, resetting the invested sum after transferring. The solution should ensure the Pre-ICO has ended and the contract is in a valid state before executing the transfer.",
        "url": 914
    },
    {
        "nl_input": "The query requires a function to handle refunds based on a proposal number, refund amount, and fees payable by the claimer. It needs to ensure the proposal hasn't been executed, verify available funds, update balances, transfer the refund, and emit relevant events for successful or unsuccessful proposals.",
        "url": 915
    },
    {
        "nl_input": "The query requires implementing minimum and maximum limits for withdrawal in a contract. The provided code examples show functions to withdraw funds, set a minimum withdrawal amount, and ensure sufficient balance for withdrawal. The requirement description should focus on defining a function to set the minimum withdrawal limit and possibly incorporating a maximum withdrawal limit within the same context.",
        "url": 916
    },
    {
        "nl_input": "The query requires a function to return the Krown balance of a given address. It needs a contract with a `balanceOf` function, which takes an address as input and returns the balance associated with that address. The function should be public, view-only, and correctly reference the balance mapping for the provided address.",
        "url": 917
    },
    {
        "nl_input": "The query requires a function to decode an RLPItem into an address. Specifically, it needs to check if the RLPItem is data, decode it to ensure the length is 20 bytes, and then use assembly to extract the address by manipulating byte values. The result should return the decoded address.",
        "url": 918
    },
    {
        "nl_input": "The query requires a function to remove a policy rule associated with a specific signature, contract address, and group name. The function should validate inputs, check group existence, update policy data structures, adjust limits, and emit an event upon successful removal of the rule.",
        "url": 919
    },
    {
        "nl_input": "The query requires a function to prevent targets from sending or receiving tokens by setting Unix times. It needs to accept target addresses and corresponding Unix timestamps, ensuring the lock duration is valid and updating the lock status accordingly. The function should also emit an event indicating the locked funds with their unlock time.",
        "url": 920
    },
    {
        "nl_input": "The query requires a method that implements core game logic, specifically tracking a unique button click event and storing related metadata. This includes generating events for the click and transferring data or value, ensuring the method can only be called once per game generation, and returning an identifier for the latest click.",
        "url": 921
    },
    {
        "nl_input": "The query requires a function to update the inflation rate yearly, callable by anyone. It needs to ensure at least one year has passed since the last update and adjust the inflation rate accordingly, affecting mint amounts for different parties (pool, owner, staking) based on the updated rate.",
        "url": 922
    },
    {
        "nl_input": "The query requires a function that calculates the time remaining until the next interest payout. It should return a timestamp or duration indicating when the next payout will occur, ensuring it's only applicable before a specified stop interval. The function is intended for user information and not for core functionality.",
        "url": 923
    },
    {
        "nl_input": "The query requires a function to calculate or retrieve the price for a given key (n), considering keys and decimals. It needs a method that either computes the price using n as input or fetches the price with proper decimal formatting, avoiding floating numbers. The solution should return the price value formatted appropriately with decimals.",
        "url": 924
    },
    {
        "nl_input": "The query requires a function that allows a specified address (_spender) to withdraw tokens from the user's account up to a certain amount (_value). The function should approve the spender for a specific limit and emit an event confirming the approval. It may also include conditions to prevent re-approval unless explicitly reset.",
        "url": 925
    },
    {
        "nl_input": "The query requires a function to withdraw funds from a contract. It needs to check conditions such as available balance and possibly user roles or system states. Upon meeting requirements, it transfers specified amounts to the sender's address and may emit events or delete related data post-withdrawal. Admin privileges or specific user statuses could be necessary for execution.",
        "url": 926
    },
    {
        "nl_input": "The query requires a function to convert all of the caller's affiliate rewards into tokens. Specifically, it needs to handle the caller's reward balance, reset it after conversion, and possibly interact with other functions to complete the token purchase and notify about reinvestment.",
        "url": 927
    },
    {
        "nl_input": "The query requires a function to transfer ownership of a Vanity URL, ensuring the new address does not already have a Vanity URL and the current owner has one. Upon successful transfer, it updates mappings, emits a transfer event, and deletes the previous owner's mapping.",
        "url": 928
    },
    {
        "nl_input": "The query requires a function that allows users to retrieve their balance or specific personal information related to the contract. The most relevant code should provide a mechanism for users to access their own data, such as account balance or player info, using external or public functions with proper modifiers for security and correctness.",
        "url": 929
    },
    {
        "nl_input": "The query requires a function for an internal token transfer specific to AIRA, involving source and destination addresses along with the token amount. The function checks if the source balance is sufficient, updates balances of both addresses upon successful validation, and emits a transfer event indicating the transaction details.",
        "url": 930
    },
    {
        "nl_input": "The query requires a function to retrieve the token balance of a specified address. The provided code snippets demonstrate implementations of a `balanceOf` function, which takes an address as input (e.g., `who`, `_owner`, or `tokenOwner`) and returns the balance associated with that address from a mapping named `balances`. The result is a uint value representing the balance.",
        "url": 931
    },
    {
        "nl_input": "The query requires a function to initiate a contribution process, ensuring it is executed by the owner and at a specific stage (Setup). The relevant code should transition the stage to \"Started,\" record the starting block number, and confirm ownership and correct stage before execution.",
        "url": 932
    },
    {
        "nl_input": "The query requires a function to set multiple pixels in one transaction, ensuring the lengths of indexes and colors arrays match. It should handle potential out-of-gas errors and revert if no pixels are set. The function must process each pixel, updating only unset ones, and finalize the canvas if needed.",
        "url": 933
    },
    {
        "nl_input": "The query requires a mechanism to throw an exception if a function is called before the crowdsale start time. It needs a modifier or function that ensures the crowdsale startTime has been reached, using a condition like 'now >= startTime' to prevent premature execution.",
        "url": 934
    },
    {
        "nl_input": "The query requires a function to send profits to a token contract. The desired functionality involves transferring accumulated profits to the specified token address after verifying conditions such as nonzero profits and completed crowdsale. The implementation should include emitting success or failure events for transparency.",
        "url": 935
    },
    {
        "nl_input": "The query requires a function to set the ID of the last token eligible for a prize, offloading sorting calculations and capping the number of sorts needed. It involves updating states and resetting counters while ensuring the token ID is within valid limits.",
        "url": 936
    },
    {
        "nl_input": "The query seeks conditions for initiating a specific stage in a contract. It requires identifying when a stage can start, potentially involving checks like stage ID, contribution caps, or timestamps. The relevant code should define logic determining if a stage's start conditions are met, possibly comparing values such as `stageId`, `contributionCap`, or `weiContributed`.",
        "url": 937
    },
    {
        "nl_input": "The query requires a function to set an external manager that can invoke 'setInterfaceImplementer' on behalf of an address. The provided code examples demonstrate enabling or setting a manager through functions like 'enableManager', 'setManager', or 'setBLInterface'. These functions typically require the caller to have specific permissions (e.g., owner or valid address) and may emit events upon successful execution.",
        "url": 938
    },
    {
        "nl_input": "The query requires a function to whitelist a funder's address, ensuring only the owner can add addresses to the whitelist. The function should validate that the address is not zero and trigger an event upon successful addition. It may also involve updating a storage contract or mapping to maintain the list of whitelisted addresses.",
        "url": 939
    },
    {
        "nl_input": "The query requires logic to set minimum and maximum limits for a transaction in wei. The code should include parameters for defining these limits, with the maximum limit being optional (indicated by 0 if no maximum is set). It must ensure the minimum value does not exceed the maximum and emit an event upon successful limit changes.",
        "url": 940
    },
    {
        "nl_input": "The query requires a function to create AVALANCHE ICE Tokens, specifying an address to hold all tokens and manage community contributions. The selected code should facilitate token creation, transfer tokens to the designated address, and ensure proper allocation for community contributions while maintaining control over token distribution.",
        "url": 941
    },
    {
        "nl_input": "The query requires a function to determine if the current time is within a pre-sale period, using start and end timestamps. It should return a boolean value indicating whether the pre-sale is active based on the current time or a given date falling between predefined pre-sale start and end times.",
        "url": 942
    },
    {
        "nl_input": "The query requires a function to retrieve the block numbers for all revisions of a specific blob identified by its ID. The function should take the blob ID as input and return an array of block numbers corresponding to each revision of the blob, iterating through all available revisions and collecting their respective block numbers.",
        "url": 943
    },
    {
        "nl_input": "The query requires a function to set up a bounty pool by specifying its address. The needed code should include a function that accepts an address parameter and assigns it to a bounty pool variable, ensuring only authorized users can execute this setup. This involves identifying a suitable contract function with the required functionality for configuring the bounty pool address.",
        "url": 944
    },
    {
        "nl_input": "The query requires a function to retrieve player information, including ID, name, address, scores (confirmed and unconfirmed), and activity status, based on a board hash and player ID. It needs a getter method that accesses stored player data and returns these specific details in a structured format. The focus is on retrieving comprehensive player details from a given board context.",
        "url": 945
    },
    {
        "nl_input": "The query requires a function that allows an admin to finalize a delegation process after a day. The function should ensure the delegation is valid and executed by the admin or owner, with conditions checking the delegate's operation details and updating the delegation accordingly. It involves confirming the delegate's status and completing the delegation process.",
        "url": 946
    },
    {
        "nl_input": "The query requires a function to receive WEDU tokens from another user, specifying the sender (_from), receiver (_to), and amount (_value) of tokens to be transferred. The function should ensure sufficient balance and approval before executing the transfer, returning true upon successful completion.",
        "url": 947
    },
    {
        "nl_input": "The query requires a function to calculate the price for tokens based on the current stage of a sale. The function should consider factors like the stage of the sale, token price, and any applicable fees, ensuring it returns zero if the sale has ended or tokens have been distributed. It must dynamically compute the price according to the ongoing stage.",
        "url": 948
    },
    {
        "nl_input": "The query requires a mechanism to lookup and manage base stats for monsters with the same ID, allowing stat retrieval by monster ID and facilitating evolution through ID changes to optimize gas costs and reduce transaction complexity. The focus is on storing and updating monster stats efficiently within a smart contract system.",
        "url": 949
    },
    {
        "nl_input": "The query requires implementing a function to release purchased tokens to buyers during the mainsale, adhering to Eidoo's ICOEngineInterface. It involves calculating tokens and bonuses based on the purchase value, ensuring correct distribution of tokens, handling refunds if necessary, and emitting events for token purchases and refunds. The solution must integrate with the minting process and transfer funds appropriately.",
        "url": 950
    },
    {
        "nl_input": "The query requires a code feature that ensures only authorized users (owner, depositor, or beneficiary) can execute specific functions. It involves implementing a modifier or function logic to restrict access, using conditions to verify the caller's identity against predefined authorized accounts, and reverting the call if unauthorized.",
        "url": 951
    },
    {
        "nl_input": "The query requires a function to airdrop tokens to multiple accounts. It needs to take a source address, an array of destination addresses, and corresponding token amounts as inputs. The function should ensure the lengths of destination and value arrays match, then transfer specified token amounts from the source to each destination address.",
        "url": 952
    },
    {
        "nl_input": "The query requires a function to check if a given address has transfer approval for a specific Cutie. The needed code should verify whether the provided address matches the approved address stored for the specified Cutie ID, ensuring proper authorization before transferring ownership. This involves comparing the address with the internally stored approved address for the given Cutie ID.",
        "url": 953
    },
    {
        "nl_input": "The query requires a modifier that restricts function access to the GDPOracle account, throwing an error if called by any other account. This ensures only the designated GDPOracle can execute specific functions, maintaining security and authorization control within the smart contract.",
        "url": 954
    },
    {
        "nl_input": "The query requires a function to retrieve detailed information about a specific redemption performed by a particular address, including the redemption ID, reason, and value. The solution should accept the address and the redemption index as inputs and ensure the address is valid and the index is within the appropriate range.",
        "url": 955
    },
    {
        "nl_input": "The query requires a function to transfer animals from one contract to another, facilitating easier contract updates. It involves identifying animals owned by the sender, transferring specific animal types and their associated values to a new contract, and handling any remaining winnings to be sent back to the sender. The solution must manage mappings, arrays, and value transfers accurately.",
        "url": 956
    },
    {
        "nl_input": "The query requires a function to mint tokens, specifying the recipient address and token ID. It involves adding tokens to the recipient's balance, ensuring the address is valid, and emitting a transfer event to reflect the minting process. The function should handle internal minting logic and maintain token supply integrity.",
        "url": 957
    },
    {
        "nl_input": "The query requires a function allowing the owner to delist an entity by setting its cap to 0. This involves a mechanism where the owner can modify caps (minimum or maximum) associated with an address, effectively removing it by resetting the cap value. The provided code snippets include examples of owner-controlled functions for listing addresses with caps and modifying blacklist statuses.",
        "url": 958
    },
    {
        "nl_input": "The query requires a function to manually start a crowdsale, callable only by the owner. It should allow starting the ICO before the designated date and can undo a stopped crowdsale in case of human error. The function sets the crowdsale status and adjusts timing parameters accordingly.",
        "url": 959
    },
    {
        "nl_input": "The query requires a function to return the deed identifier of an owner at a specific index. It involves iterating through all deeds, checking ownership, and returning the identifier when the specified index matches. The function ensures the index is within the valid range of deeds owned by the given address.",
        "url": 960
    },
    {
        "nl_input": "The query requires a modifier to ensure a function is called only once. The relevant code demonstrates a modifier named `onlyOnce`, which uses a condition `require(functAttempts <= 0)` to limit the function execution to a single call, preventing subsequent invocations. This ensures the function maintains a one-time use constraint effectively.",
        "url": 961
    },
    {
        "nl_input": "The query requires a function to change the development fee, ensuring only authorized users can update it within specified limits. The function should accept a new fee value as input, validate it, and then set it as the current development fee, potentially emitting an event to log the change for transparency.",
        "url": 962
    },
    {
        "nl_input": "The query requires overriding the `transferFrom` function to add custom logic before executing the base functionality. This includes checking conditions like token tradeability, KYC requirements, or taking snapshots of balances for auditing or tracking purposes, while ensuring the transfer complies with specified constraints such as unlocked tokens.",
        "url": 963
    },
    {
        "nl_input": "The query requires a function to sell a specified amount of tokens to a contract. It involves transferring tokens from the contract's available supply to the specified investor address, ensuring the token balance and available supply are updated accordingly. The solution should handle internal token transfers and manage the token balances effectively.",
        "url": 964
    },
    {
        "nl_input": "The query requires a function to enable or disable an address as the sender of EUR-T. The desired code should allow setting permissions for specific addresses, enabling or disabling their ability to act as senders, with proper access control to ensure only authorized entities can modify these settings.",
        "url": 965
    },
    {
        "nl_input": "The query requires a function to handle refunds when specific conditions are met, such as refund availability or sale unsuccessfulness. It ensures the caller's balance is reset and transfers the refunded amount back to the user. The description focuses on implementing a refund mechanism with condition checks and balance management.",
        "url": 966
    },
    {
        "nl_input": "The query requires a function to allow users to buy shares by sending a specific value. The function should calculate the amount of shares based on the input value, update the total supply, transfer shares to the buyer, and possibly allocate a portion to the owner. It must also handle errors, such as reverting if minting is finished.",
        "url": 967
    },
    {
        "nl_input": "The query requires sending an Oraclize query for a specified API, ensuring sufficient ETH balance to cover the query fee. It involves checking conditions, such as query timing and status, and selecting the appropriate API (API or API2) based on prior query execution. If successful, it updates query metadata and emits confirmation events. If not, it notifies about insufficient funds.",
        "url": 968
    },
    {
        "nl_input": "The query requires a function to confirm automatic selling based on available tokens. It checks if the number of tokens is sufficient for the requested amount and returns a boolean value indicating success or failure. The function 'confirmSell' evaluates whether the ICO's token balance meets or exceeds the specified amount, ensuring valid autosell confirmation.",
        "url": 969
    },
    {
        "nl_input": "The query requires an internal method to create a new Zodiac by specifying parameters such as matron ID, sire ID, generation, genes, owner, and zodiac type. The method ensures valid inputs, initializes cooldown details, stores the new Zodiac in memory, updates the total count, emits a birth event, and transfers ownership to the specified address.",
        "url": 970
    },
    {
        "nl_input": "The query requires a function that is automatically executed upon deployment. The requirement focuses on identifying code that sets up an initial configuration or stage during the deployment process, ensuring it aligns with the contract's intended functionality right after deployment. This involves modifiers or functions restricting execution to specific stages or conditions.",
        "url": 971
    },
    {
        "nl_input": "The query requires identifying the index of a newly created snapshot in a token system. It involves creating a snapshot of token holder balances, where the index is returned as a uint256 value. The process includes updating snapshot-related data structures and emitting an event to notify about the new snapshot creation.",
        "url": 972
    },
    {
        "nl_input": "The query requires a function to retrieve the level of a hero based on a unique token ID. Specifically, it needs a mechanism where an external call can return the current level of a hero instance associated with the given token ID in a blockchain smart contract context.",
        "url": 973
    },
    {
        "nl_input": "The query requires a function to return the total number of tokens in existence. This involves defining a function named `totalSupply` within a contract, which calculates and returns the total supply of tokens as a uint256 value, typically representing the overall token count in a blockchain-based system.",
        "url": 974
    },
    {
        "nl_input": "The query requires a function to withdraw all released vesting coins and add them to the user's balance. It involves calculating the released amount based on vesting schedules, updating the withdrawn amounts, and increasing the user's balance accordingly. The focus is on handling multiple vesting entries per user and ensuring accurate accounting of released and remaining tokens.",
        "url": 975
    },
    {
        "nl_input": "The query requires a function to create tokens for fees pledged by an owner, involving internal operations within a contract. It needs to handle conditions like checking the controller, updating block numbers, converting pledged amounts to tokens, generating tokens for the owner, and emitting contribution logs. The focus is on internal token generation and fee pledging mechanics.",
        "url": 976
    },
    {
        "nl_input": "The query requires a function to allow marketing contributors to withdraw their rewarded tokens. It needs to specify the contributor's address and the number of tokens to withdraw, ensuring the requested tokens do not exceed the available reward balance. The function should update the contributor's token balances and transfer the tokens accordingly.",
        "url": 977
    },
    {
        "nl_input": "The query requires a function to release vested tokens to the Hut34 wallet. It needs to check if the current time is beyond the next release date, update the release date, and transfer a specific amount of vested tokens to the Hut34 retention address. The solution should ensure proper timing and accurate token distribution.",
        "url": 978
    },
    {
        "nl_input": "The query requires a function to set the symbol of a contract. It needs a method that accepts a parameter for the symbol and updates the contract's symbol accordingly. The function may include modifiers for access control, such as only allowing the owner to update the symbol. Additionally, it could emit an event upon successful updating of the symbol.",
        "url": 979
    },
    {
        "nl_input": "The query requires a function that allows anyone to transfer Change tokens after trading has started, specifying the recipient address and the number of tokens to be transferred. The function should ensure trading has commenced and may include additional logic for token transfer validation and handling specific cases, such as owner-related transfers.",
        "url": 980
    },
    {
        "nl_input": "The query requires implementing a functionality to revert transactions if the sender is not the designated whiteListAgent. It involves using a modifier or function to ensure only the whiteListAgent can execute certain operations, with potential extensions for disabling or modifying whitelist states by the contract owner.",
        "url": 981
    },
    {
        "nl_input": "The query requires a function to adjust an inflation rate that starts at 100, decreases by 30 annually until reaching 10, then decreases by 0.5. The code should handle rate adjustments based on specific conditions and time intervals, ensuring proper calculation and application of the inflation rate throughout its decreasing phases.",
        "url": 982
    },
    {
        "nl_input": "The query requires a function to transfer tokens from one user address to another. It needs parameters for the recipient address and the value of tokens to transfer, ensuring the value is positive and adjusting balances accordingly. The function should return a boolean indicating success and emit a transfer event.",
        "url": 983
    },
    {
        "nl_input": "The query requires a function to remove an auction from public view and return the token to the seller. This involves canceling the auction, transferring the token back to the seller, and ensuring the auction is no longer accessible or visible to the public. The solution should handle these operations securely and efficiently within a smart contract environment.",
        "url": 984
    },
    {
        "nl_input": "The query requires a function to approve the minting of a specified amount of tokens (_amount) that will be assigned to a specific address (_owner). The function should ensure that the minting process adheres to supply limits and correctly updates token balances and locks, returning true upon successful approval.",
        "url": 985
    },
    {
        "nl_input": "The query requires a function to determine the total jackpot value. If the jackpot is completed, it should return the final jackpot value; otherwise, it returns the contract's balance. The relevant code provides a function `getJackpotTotalValue` that fulfills this requirement by checking the `jackpotCompleted` status and returning either `finalJackpotValue` or `address(this).balance`.",
        "url": 986
    },
    {
        "nl_input": "The query requires a function to calculate how much ETH a user can receive when selling a specific amount of BOB tokens. It needs to take the token amount as input and return the equivalent ETH based on a predefined rate, ensuring accurate conversion and handling edge cases like zero rate.",
        "url": 987
    },
    {
        "nl_input": "The query requires a modifier to control access for adding deposits. The modifier should allow only specific addresses or those granted deposit access to execute deposit-related functions, ensuring security and authorization before proceeding with the deposit operation. This involves checking if the sender is authorized or explicitly permitted for deposit access.",
        "url": 988
    },
    {
        "nl_input": "The query requires a function to determine if an address can bypass the global freeze. It needs a parameter for the target address and another for the bypass status (true to bypass). The function should update the bypass status for the specified address, allowing it to bypass the global freeze if set to true.",
        "url": 989
    },
    {
        "nl_input": "The query requires a callback function for handling Oraclize random number results in a betting system. It involves verifying the proof, generating a random number from the result, determining winners or losers based on random values, and distributing winnings while managing edge cases like equal random numbers or failed transactions. The function ensures proper bet states and error handling throughout the process.",
        "url": 990
    },
    {
        "nl_input": "The query requires a function allowing the owner to update the conversion rate (TCR to ETH) within a specified range. The function should ensure only the owner can make this change and include a parameter for setting the new rate, with validation to confirm it falls within acceptable limits.",
        "url": 991
    },
    {
        "nl_input": "The query requires a function to check if an account is frozen. Specifically, it needs a boolean return indicating the freeze status of a given account address. The function should access a mapping or storage that holds freeze statuses for each account and provide a straightforward true/false output based on the account's current status.",
        "url": 992
    },
    {
        "nl_input": "The query requires a mechanism for the owner to send any transaction, akin to a multi-signature setup, ensuring campaigns can handle DAC/campaign tokens and transfer pledges to other DACs/campaigns. It needs a modifier or function restricting token transfers to authorized entities (owner or distributors) while allowing transaction execution upon specific conditions.",
        "url": 993
    },
    {
        "nl_input": "The query requires a function to disable or nullify the contract, accessible only by the owner. It aims for functionality that sets a boolean value to true, effectively disabling the contract without necessarily removing it from the blockchain state. The focus is on implementing a reversible or irreversible disable mechanism.",
        "url": 994
    },
    {
        "nl_input": "The query requires a function to remove a minor owner, which can only be executed by the major/actual owner wallet. The function should verify the minor owner's existence, update ownership records by removing the minor owner, and adjust the major owner's share accordingly. It ensures proper authorization and maintains ownership integrity within the contract.",
        "url": 995
    },
    {
        "nl_input": "The query requires retrieving the value of a specific node, represented by 'nodeId'. The relevant code should define a function capable of accepting a node identifier and returning its associated value. This involves mapping or lookup operations to fetch the corresponding value for the given node from storage or computation.",
        "url": 996
    },
    {
        "nl_input": "The query requires defining who can transfer tokens, specifying that only the owner and designated distributors have the permission to transfer tokens. The relevant code implements a modifier or function to restrict token transfers to these authorized entities, ensuring proper access control through conditions and mappings.",
        "url": 997
    },
    {
        "nl_input": "The query requires a function to set a charity address, allowing the contract owner to update the charity's address. The most relevant code provides a function named \"setCharity\" that accepts an address parameter and updates the charityAddress variable, ensuring only the contract owner can execute this change.",
        "url": 998
    },
    {
        "nl_input": "The query requires a function to set the server-side address. The function should allow an owner or authorized entity to change the address, ensuring the new address is valid and not the same as the current one. It may also involve emitting an event to confirm the address change.",
        "url": 999
    }
]